diff -urN libwnck.orig/config.h.in libwnck.new/config.h.in
--- libwnck.orig/config.h.in	2008-08-06 23:43:14.009985000 +0100
+++ libwnck.new/config.h.in	2008-08-06 23:43:40.045900000 +0100
@@ -32,6 +32,7 @@
 
 /* Define if you have libstartup-notification */
 #undef HAVE_STARTUP_NOTIFICATION
+#undef HAVE_XTSOL
 
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
diff -urN libwnck.orig/configure.in libwnck.new/configure.in
--- libwnck.orig/configure.in	2008-08-06 23:43:14.618321000 +0100
+++ libwnck.new/configure.in	2008-08-06 23:43:40.049192000 +0100
@@ -139,6 +139,15 @@
 dnl Honor ACLOCAL_FLAGS for --enable-maintainer-mode
 ACLOCAL="$ACLOCAL $ACLOCAL_FLAGS"
 
+case "$host" in
+    *-*-solaris*)
+        AC_CHECK_HEADERS(X11/extensions/Xtsol.h sys/tsol/label_macro.h libgnometsol/userattr.h,
+          AC_DEFINE(HAVE_XTSOL, , [Building with XTSOL support]))
+        ;;
+    *)
+        ;;
+esac
+
 ##################################################
 # Checks for gtk-doc and docbook-tools
 ##################################################
diff -urN libwnck.orig/configure.in.orig libwnck.new/configure.in.orig
--- libwnck.orig/configure.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ libwnck.new/configure.in.orig	2008-08-06 23:43:15.750667000 +0100
@@ -0,0 +1,154 @@
+AC_INIT(libwnck/window.h)
+
+AM_CONFIG_HEADER(config.h)
+
+AM_INIT_AUTOMAKE(libwnck, 2.23.4)
+AM_MAINTAINER_MODE
+GNOME_COMMON_INIT
+GNOME_MAINTAINER_MODE_DEFINES
+
+dnl libtool versioning for libwnck
+
+dnl increment if the interface has additions, changes, removals.
+LIBWNCK_CURRENT=25
+
+dnl increment any time the source changes; set to
+dnl  0 if you increment CURRENT
+LIBWNCK_REVISION=8
+
+dnl increment if any interfaces have been added; set to 0
+dnl  if any interfaces have been changed or removed. removal has
+dnl  precedence over adding, so set to 0 if both happened.
+LIBWNCK_AGE=3
+
+AC_SUBST(LIBWNCK_CURRENT)
+AC_SUBST(LIBWNCK_REVISION)
+AC_SUBST(LIBWNCK_AGE)
+
+IT_PROG_INTLTOOL([0.40.0])
+
+AC_PROG_CC
+AC_ISC_POSIX
+AC_HEADER_STDC
+AC_LIBTOOL_WIN32_DLL
+AM_PROG_LIBTOOL
+
+changequote(,)dnl
+if test "x$GCC" = "xyes"; then
+  case " $CFLAGS " in
+  *[\ \	]-Wall[\ \	]*) ;;
+  *) CFLAGS="$CFLAGS -Wall" ;;
+  esac
+
+  if test "x$enable_ansi" = "xyes"; then
+    case " $CFLAGS " in
+    *[\ \	]-ansi[\ \	]*) ;;
+    *) CFLAGS="$CFLAGS -ansi" ;;
+    esac
+
+    case " $CFLAGS " in
+    *[\ \	]-pedantic[\ \	]*) ;;
+    *) CFLAGS="$CFLAGS -pedantic" ;;
+    esac
+  fi
+fi
+changequote([,])dnl
+
+GNOME_COMPILE_WARNINGS(maximum)
+
+AC_ARG_ENABLE(deprecations,
+              [AC_HELP_STRING([--enable-deprecations],
+                              [warn about deprecated usages [default=no]])],,
+              [enable_deprecations=no])
+
+if test "x$enable_deprecations" = "xyes"; then
+   DISABLE_DEPRECATED_CFLAGS=$DISABLE_DEPRECATED
+   AC_SUBST(DISABLE_DEPRECATED_CFLAGS)
+fi
+
+GETTEXT_PACKAGE=libwnck
+AC_SUBST(GETTEXT_PACKAGE)
+AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,"$GETTEXT_PACKAGE", [Package name])
+
+AM_GLIB_GNU_GETTEXT
+
+# AM_GLIB_GNU_GETTEXT above substs $DATADIRNAME
+# this is the directory where the *.{mo,gmo} files are installed
+wncklocaledir='${prefix}/${DATADIRNAME}/locale'
+AC_SUBST(wncklocaledir)
+
+AC_PATH_PROG(PKG_CONFIG, pkg-config)
+
+AC_MSG_CHECKING([if building with libstartup-notification])
+STARTUP_NOTIFICATION_REQUIRED=0.4
+if $PKG_CONFIG --atleast-version $STARTUP_NOTIFICATION_REQUIRED libstartup-notification-1.0; then
+  AC_MSG_RESULT([yes])
+  AC_DEFINE_UNQUOTED(HAVE_STARTUP_NOTIFICATION, 1, [Define if you have libstartup-notification])
+  STARTUP_NOTIFICATION_PACKAGE=libstartup-notification-1.0
+else
+  AC_MSG_RESULT([no])
+  STARTUP_NOTIFICATION_PACKAGE=
+fi
+AC_SUBST(STARTUP_NOTIFICATION_PACKAGE)
+
+PKG_CHECK_MODULES(XLIB, x11,
+    X11_PACKAGE=x11,
+    [X11_PACKAGE=
+     AC_PATH_XTRA
+     if test "x$no_x" = xyes; then
+       AC_MSG_ERROR("no (requires X development libraries)")
+     else
+       XLIB_LIBS="$X_PRE_LIBS $X_LIBS -lX11 $X_EXTRA_LIBS"
+       XLIB_CFLAGS=$X_CFLAGS
+     fi])
+AC_SUBST(X11_PACKAGE)
+
+AC_MSG_CHECKING([if building with X Resource Information Extension Library])
+if $PKG_CONFIG xres; then
+  AC_MSG_RESULT([yes])
+  AC_DEFINE_UNQUOTED(HAVE_XRES, 1, [Define if you have the XRes library])
+  XRES_PACKAGE=xres
+else
+  AC_CHECK_LIB(XRes, XResQueryExtension,          
+               [XLIB_LIBS="$XLIB_LIBS -lXRes -lXext"
+                AC_DEFINE_UNQUOTED(HAVE_XRES, 1, [Define if you have the XRes library])
+                AC_MSG_RESULT([yes])],
+               AC_MSG_RESULT([no]),
+               $XLIB_LIBS -lXext)
+  XRES_PACKAGE=
+fi
+AC_SUBST(XRES_PACKAGE)
+AC_SUBST(XLIB_CFLAGS)
+AC_SUBST(XLIB_LIBS)
+
+PKG_CHECK_MODULES(LIBWNCK, gtk+-2.0 >= 2.11.3 glib-2.0 >= 2.13.0 gobject-2.0 >= 2.13.0 $STARTUP_NOTIFICATION_PACKAGE $XRES_PACKAGE)
+AC_SUBST(LIBWNCK_LIBS)
+AC_SUBST(LIBWNCK_CFLAGS)
+
+GLIB_GENMARSHAL=`$PKG_CONFIG --variable=glib_genmarshal glib-2.0`  
+AC_SUBST(GLIB_GENMARSHAL)
+
+AC_PATH_PROG(GDK_PIXBUF_CSOURCE, gdk-pixbuf-csource, no)
+
+if test x"$GDK_PIXBUF_CSOURCE" = xno; then
+  AC_MSG_ERROR([gdk-pixbuf-csource executable not found in your path - should be installed with GTK])
+fi
+
+AC_SUBST(GDK_PIXBUF_CSOURCE)
+
+dnl Honor ACLOCAL_FLAGS for --enable-maintainer-mode
+ACLOCAL="$ACLOCAL $ACLOCAL_FLAGS"
+
+##################################################
+# Checks for gtk-doc and docbook-tools
+##################################################
+GTK_DOC_CHECK([1.9])
+
+AC_OUTPUT([
+Makefile
+doc/Makefile
+po/Makefile.in
+libwnck/Makefile
+libwnck-1.0.pc
+libwnck-1.0-uninstalled.pc
+])
diff -urN libwnck.orig/libwnck/Makefile.am libwnck.new/libwnck/Makefile.am
--- libwnck.orig/libwnck/Makefile.am	2008-08-06 23:43:13.585347000 +0100
+++ libwnck.new/libwnck/Makefile.am	2008-08-06 23:43:40.052830000 +0100
@@ -28,6 +28,11 @@
 wnck_built_headers = $(wnck_built_installed_headers) wnck-marshal.h
 wnck_built_cfiles = wnck-enum-types.c wnck-marshal.c
 
+wncktsol_sources =              \
+        wnck-tsol.c
+wncktsol_h_sources =            \
+        wnck-tsol.h
+
 wnck_accessibility_files =			\
 	pager-accessible.c			\
 	pager-accessible.h			\
@@ -55,6 +60,11 @@
 	workspace.c		\
 	xutils.c		\
 	xutils.h		\
+	tsol-pics.h		\
+	trusted-tooltips.c	\
+	trusted-tooltips.h	\
+	$(wncktsol_sources)		\
+	$(wncktsol_h_sources)	\
 	$(wnck_accessibility_files)
 
 $(libwnck_1_la_OBJECTS): inlinepixbufs.h
diff -urN libwnck.orig/libwnck/pager.c libwnck.new/libwnck/pager.c
--- libwnck.orig/libwnck/pager.c	2008-08-06 23:43:13.356087000 +0100
+++ libwnck.new/libwnck/pager.c	2008-08-06 23:43:40.066590000 +0100
@@ -29,6 +29,7 @@
 #include <math.h>
 #include <glib/gi18n-lib.h>
 
+#include <config.h>
 #include "pager.h"
 #include "workspace.h"
 #include "window.h"
@@ -59,6 +60,11 @@
  * layout.
  */
 
+#ifdef HAVE_XTSOL
+#include "trusted-tooltips.h"
+#include "wnck-tsol.h"
+#endif
+
 #define N_SCREEN_CONNECTIONS 11
 
 struct _WnckPagerPrivate
@@ -82,6 +88,9 @@
   WnckWindow *drag_window;
 
   GdkPixbuf *bg_cache;
+#ifdef HAVE_XTSOL
+  TrustedTooltips *tooltips;
+#endif /* HAVE_XTSOL */  
 
   int layout_manager_token;
 
@@ -345,8 +354,8 @@
   attributes.colormap = gtk_widget_get_colormap (widget);
   attributes.event_mask = gtk_widget_get_events (widget) | GDK_EXPOSURE_MASK |
 	  		  GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
-			  GDK_LEAVE_NOTIFY_MASK | GDK_POINTER_MOTION_MASK |
-			  GDK_POINTER_MOTION_HINT_MASK;
+			  GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+			  GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK;
 
   attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
 
@@ -356,6 +365,11 @@
   widget->style = gtk_style_attach (widget->style, widget->window);
   gtk_style_set_background (widget->style, widget->window, GTK_STATE_NORMAL);
 
+#ifdef HAVE_XTSOL
+  if (_wnck_use_trusted_extensions() == TRUE)
+    trusted_tooltips_set_tip (pager->priv->tooltips, GTK_WIDGET (pager), "","", NULL,  NULL);
+#endif /* HAVE_XTSOL */  
+
   /* connect to the screen of this pager. In theory, this will already have
    * been done in wnck_pager_size_request() */
   if (pager->priv->screen == NULL)
@@ -1060,7 +1074,13 @@
 
       if (!wnck_workspace_is_virtual (space))
         {
+#ifdef HAVE_XTSOL
+          if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+            gdk_cairo_set_source_color (cr, &widget->style->light[state]);
+          else
+#endif /* HAVE_XTSOL */
           gdk_cairo_set_source_color (cr, &widget->style->dark[state]);
+
           cairo_rectangle (cr, rect->x, rect->y, rect->width, rect->height);
           cairo_fill (cr);
         }
@@ -1237,6 +1257,53 @@
       cairo_stroke (cr);
       cairo_destroy (cr);
     }
+#ifdef HAVE_XTSOL
+    {
+      #define DEFAULT_COLOR	"white"
+      const char *label = NULL;
+      char *colorname;
+      int error;
+      GdkColor label_color;
+      m_label_t *mlabel = NULL;
+
+      if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+	{
+          label = wnck_workspace_get_label (wnck_screen_get_workspace(pager->priv->screen, workspace));
+	  if (label != NULL && (libtsol_str_to_label (label, &mlabel, MAC_LABEL, L_NO_CORRECTION, &error) == 0)) 
+	  {
+		  cairo_t *cr; 
+		  cr = gdk_cairo_create (widget->window);
+
+		  libtsol_label_to_str (mlabel, &colorname, M_COLOR, DEF_NAMES);
+
+		  if (colorname == NULL)
+			  colorname = g_strdup(DEFAULT_COLOR);
+
+		  gdk_color_parse ((const char*)colorname, &label_color);
+
+		  g_free (colorname);
+
+		  cairo_set_source_rgba (cr,
+				  (double) label_color.red / 65535,
+				  (double) label_color.green / 65535,
+				  (double) label_color.blue / 65535,
+				  0.5);
+		  cairo_set_line_width (cr, 1.0);
+		  cairo_rectangle (cr,
+				  rect->x + 0.5, rect->y + 0.5,
+				  rect->width - 1, rect->height - 1);
+		  cairo_fill (cr);
+		  cairo_destroy (cr);
+	  }
+	  else
+	    {
+	      g_warning("Could not validate sensitivity label \"%s\"", label ? label : "no label defined");
+	    }
+	}
+	  
+    }
+#endif /*HAVE_XTSOL*/
+
 }
 
 static gboolean
@@ -1747,6 +1814,14 @@
 
   gdk_window_get_pointer (widget->window, &x, &y, NULL);
 
+#ifdef HAVE_XTSOL
+    if (_wnck_use_trusted_extensions () == TRUE) { 
+      int i = workspace_at_point (pager, event->x, event->y, NULL, NULL);
+      if (i >= 0)
+	g_object_set_data (G_OBJECT (pager), "tip_ws", (gpointer) wnck_screen_get_workspace (pager->priv->screen, i));
+    }
+#endif /* HAVE_XTSOL */  
+
   if (!pager->priv->dragging &&
       pager->priv->drag_window != NULL &&
       gtk_drag_check_threshold (widget,
@@ -1940,6 +2015,14 @@
   WnckPager *pager;
   
   pager = g_object_new (WNCK_TYPE_PAGER, NULL);
+#ifdef HAVE_XTSOL  
+  if (_wnck_use_trusted_extensions () == TRUE) {
+    pager->priv->tooltips = trusted_tooltips_new ();
+    trusted_tooltips_set_pager (pager->priv->tooltips, pager);
+    gtk_object_ref (GTK_OBJECT (pager->priv->tooltips));
+    gtk_object_sink (GTK_OBJECT (pager->priv->tooltips));
+  }
+#endif /* HAVE_XTSOL */  
 
   return GTK_WIDGET (pager);
 }
diff -urN libwnck.orig/libwnck/private.h libwnck.new/libwnck/private.h
--- libwnck.orig/libwnck/private.h	2008-08-06 23:43:13.349065000 +0100
+++ libwnck.new/libwnck/private.h	2008-08-06 23:43:40.073263000 +0100
@@ -35,6 +35,9 @@
 #ifdef HAVE_STARTUP_NOTIFICATION
 #include <libsn/sn.h>
 #endif
+#ifdef HAVE_XTSOL
+#include <tsol/label.h>
+#endif
 
 G_BEGIN_DECLS
 
@@ -102,9 +105,23 @@
 
 void _wnck_workspace_update_name (WnckWorkspace *workspace,
                                   const char    *name);
+#ifdef HAVE_XTSOL
+void _wnck_workspace_update_label (WnckWorkspace *workspace,
+                                   const char    *label);
+void _wnck_workspace_update_role (WnckWorkspace *workspace,
+                                  const char    *role);
+blrange_t * _wnck_workspace_get_range (WnckWorkspace *space);
+#endif
 void _wnck_screen_change_workspace_name (WnckScreen *screen,
                                          int         number,
                                          const char *name);
+#ifdef HAVE_XTSOL
+void _wnck_screen_change_workspace_label (WnckScreen *screen,
+                                          int         number,
+                                          const char *label);
+gboolean _wnck_check_xtsol_extension    ();
+gboolean _wnck_use_trusted_extensions	();
+#endif
 
 gboolean _wnck_workspace_set_geometry (WnckWorkspace *space, int w, int h);
 gboolean _wnck_workspace_set_viewport (WnckWorkspace *space, int x, int y);
diff -urN libwnck.orig/libwnck/screen.c libwnck.new/libwnck/screen.c
--- libwnck.orig/libwnck/screen.c	2008-08-06 23:43:13.472108000 +0100
+++ libwnck.new/libwnck/screen.c	2008-08-06 23:43:40.084085000 +0100
@@ -33,11 +33,17 @@
 #include "class-group.h"
 #include "xutils.h"
 #include "private.h"
+#include "wnck-tsol.h"
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 #include <string.h>
 #include <stdlib.h>
 
+#ifdef HAVE_XTSOL
+#include <tsol/label.h>
+#include <sys/tsol/label_macro.h> 
+#endif
+
 /**
  * SECTION:screen
  * @short_description: an object representing a screen.
@@ -122,6 +128,10 @@
   guint need_update_active_window : 1;
   guint need_update_workspace_layout : 1;
   guint need_update_workspace_names : 1;
+#ifdef HAVE_XTSOL
+  guint need_update_workspace_labels : 1;
+  guint need_update_workspace_roles : 1;
+#endif
   guint need_update_bg_pixmap : 1;
   guint need_update_showing_desktop : 1;
   guint need_update_wm : 1;
@@ -160,6 +170,10 @@
 static void update_active_window      (WnckScreen      *screen);
 static void update_workspace_layout   (WnckScreen      *screen);
 static void update_workspace_names    (WnckScreen      *screen);
+#ifdef HAVE_XTSOL
+static void update_workspace_labels   (WnckScreen      *screen);
+static void update_workspace_roles    (WnckScreen      *screen);
+#endif
 static void update_showing_desktop    (WnckScreen      *screen);
 
 static void queue_update            (WnckScreen      *screen);
@@ -602,6 +616,10 @@
   screen->priv->need_update_active_window = TRUE;
   screen->priv->need_update_workspace_layout = TRUE;
   screen->priv->need_update_workspace_names = TRUE;
+#ifdef HAVE_XTSOL
+  screen->priv->need_update_workspace_labels = TRUE;
+  screen->priv->need_update_workspace_roles = TRUE;
+#endif
   screen->priv->need_update_bg_pixmap = TRUE;
   screen->priv->need_update_showing_desktop = TRUE;
   screen->priv->need_update_wm = TRUE;
@@ -1124,6 +1142,20 @@
       screen->priv->need_update_workspace_names = TRUE;
       queue_update (screen);
     }
+#ifdef HAVE_XTSOL
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_DESKTOP_LABELS"))
+    {
+      screen->priv->need_update_workspace_labels = TRUE;
+      queue_update (screen);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_DESKTOP_ROLES"))
+    {
+      screen->priv->need_update_workspace_roles = TRUE;
+      queue_update (screen);
+    }
+#endif
   else if (xevent->xproperty.atom ==
            _wnck_atom_get ("_XROOTPMAP_ID"))
     {
@@ -2220,6 +2252,85 @@
   g_list_free (copy);
 }
 
+#ifdef  HAVE_XTSOL
+static void
+update_workspace_labels (WnckScreen *screen)
+{
+  char **labels;
+  int i;
+  GList *tmp;
+  GList *copy;
+
+  if (!screen->priv->need_update_workspace_labels)
+    return;
+
+  screen->priv->need_update_workspace_labels = FALSE;
+
+  labels = _wnck_get_utf8_list (screen->priv->xroot,
+                                _wnck_atom_get ("_NET_DESKTOP_LABELS"));
+
+  copy = g_list_copy (screen->priv->workspaces);
+
+  i = 0;
+  tmp = copy;
+  while (tmp != NULL)
+    {
+      if (labels && labels[i])
+        {
+          _wnck_workspace_update_label (tmp->data, labels[i]);
+          ++i;
+        }
+      else
+        _wnck_workspace_update_label (tmp->data, NULL);
+
+      tmp = tmp->next;
+    }
+
+  g_strfreev (labels);
+
+  g_list_free (copy);
+}
+
+static void
+update_workspace_roles (WnckScreen *screen)
+{
+  char **roles;
+  int i;
+  GList *tmp;
+  GList *copy;
+
+  if (!screen->priv->need_update_workspace_roles)
+    return;
+
+  screen->priv->need_update_workspace_roles = FALSE;
+
+  roles = _wnck_get_utf8_list (screen->priv->xroot,
+                                _wnck_atom_get ("_NET_DESKTOP_ROLES"));
+
+  copy = g_list_copy (screen->priv->workspaces);
+
+  i = 0;
+  tmp = copy;
+  while (tmp != NULL)
+    {
+      if (roles && roles[i])
+        {
+          _wnck_workspace_update_role (tmp->data, roles[i]);
+          ++i;
+        }
+      else
+        _wnck_workspace_update_role (tmp->data, NULL);
+
+      tmp = tmp->next;
+    }
+
+  g_strfreev (roles);
+
+  g_list_free (copy);
+}
+#endif /* HAVE_XTSOL */
+
+
 static void
 update_bg_pixmap (WnckScreen *screen)
 {
@@ -2305,6 +2416,10 @@
     {
       screen->priv->need_update_viewport_settings = TRUE;
       screen->priv->need_update_workspace_names = TRUE;
+#ifdef HAVE_XTSOL
+      screen->priv->need_update_workspace_labels = TRUE;
+      screen->priv->need_update_workspace_roles = TRUE;
+#endif
     }
       
   /* First get our big-picture state in order */
@@ -2317,6 +2432,15 @@
   update_active_window (screen);
   update_workspace_layout (screen);
   update_workspace_names (screen);
+#ifdef HAVE_XTSOL
+  /* IMPORTANT
+   * Workspace roles MUST be set before labels 
+   * as the valid label range for role workspaces
+   * is different from the user's min and max label
+   */
+  update_workspace_roles (screen);
+  update_workspace_labels (screen);
+#endif
   update_showing_desktop (screen);
   update_wm (screen);
   
@@ -2815,3 +2939,86 @@
 
   g_free (names);
 }
+
+#ifdef HAVE_XTSOL
+void
+_wnck_screen_change_workspace_label (WnckScreen *screen,
+                                    int         number,
+                                    const char *label)
+{
+  int n_spaces;
+  char **labels;
+  int i;
+  int error=-2;
+  m_label_t *mlabel = NULL;
+
+  static char		*lower_sl_str = NULL;
+  static char		*upper_clear_str = NULL;
+  static blrange_t	*workspace_range = NULL;
+
+  WnckWorkspace		*tmp_space = NULL;
+  
+  /* First check that we are running in a trusted windowing environment */
+  if (! _wnck_check_xtsol_extension ()) {
+      g_warning("Workspace labelling can not work with out the SUN_TSOL X extension");
+      return;
+  }
+
+  if (!_wnck_use_trusted_extensions())
+      return;
+
+  /* 
+   * Label must be validated.
+   * Convert the label string to a binary MAC_LABEL type.
+   * Then check that it is in the workspace's range which 
+   * depends on what role (if any) the workspace has.
+   */
+  
+  if (libtsol_str_to_label (label, &mlabel, MAC_LABEL, L_NO_CORRECTION, &error) < 0) {
+      g_warning("Could not validate sensitivity label \"%s\"", label);
+      return;
+  }
+
+  tmp_space = wnck_screen_get_workspace (screen, number);
+  /* need to refresh the role cache if an app is calling change label 
+   * after setting directly the _NET_DESKTOP_ROLES as this wouldn't have been 
+   * updated in libwnck yet */
+  screen->priv->need_update_workspace_roles = TRUE;
+  update_workspace_roles (screen); 
+   workspace_range = _wnck_workspace_get_range (tmp_space);
+
+  if (!libtsol_blinrange (mlabel, workspace_range)) {
+      g_warning("Could not change the sensitivity label of workspace %d because \"%s\" "
+                "appears to be outside of the workspace's label range", number, label);
+      libtsol_m_label_free (mlabel);
+      return;
+  }
+
+  n_spaces = wnck_screen_get_workspace_count (screen);
+
+  labels = g_new0 (char*, n_spaces + 1);
+
+  i = 0;
+  while (i < n_spaces) {
+      if (i == number)
+          labels[i] = (char*) label;
+      else {
+          WnckWorkspace *workspace;
+          workspace = wnck_screen_get_workspace (screen, i);
+          if (workspace) {
+              labels[i] = (char*) wnck_workspace_get_label (workspace);
+              if (labels[i] == NULL)
+                  labels[i] = (char*) ""; /* Maybe a g_warning too ? */
+          } else
+              labels[i] = (char*) ""; /* maybe this should be a g_warning too */
+      }
+      i++;
+  }
+
+  _wnck_set_utf8_list (screen->priv->xroot,
+                       _wnck_atom_get ("_NET_DESKTOP_LABELS"),
+                       labels);
+  libtsol_m_label_free (mlabel);
+  g_free (labels);
+}
+#endif /* HAVE_XTSOL */
diff -urN libwnck.orig/libwnck/tasklist.c libwnck.new/libwnck/tasklist.c
--- libwnck.orig/libwnck/tasklist.c	2008-08-06 23:43:13.368589000 +0100
+++ libwnck.new/libwnck/tasklist.c	2008-08-06 23:43:40.101354000 +0100
@@ -36,6 +36,10 @@
 #include "workspace.h"
 #include "xutils.h"
 #include "private.h"
+#ifdef HAVE_XTSOL 
+#include "wnck-tsol.h"
+#include "trusted-tooltips.h"
+#endif /* HAVE_XTSOL */
 
 /**
  * SECTION:tasklist
@@ -200,6 +204,10 @@
   GHashTable *class_group_hash;
   GHashTable *win_hash;
   
+#ifdef HAVE_XTSOL
+  TrustedTooltips *tooltips;
+#endif /*HAVE_XTSOL*/   
+
   gint max_button_width;
   gint max_button_height;
 
@@ -2123,6 +2131,10 @@
   WnckTasklist *tasklist;
 
   tasklist = g_object_new (WNCK_TYPE_TASKLIST, NULL);
+#ifdef HAVE_XTSOL
+  if (_wnck_use_trusted_extensions () == TRUE)
+    tasklist->priv->tooltips = trusted_tooltips_new ();
+#endif /*HAVE_XTSOL*/
 
   return GTK_WIDGET (tasklist);
 }
@@ -2960,6 +2972,10 @@
 	{
 	  image = gtk_image_new_from_pixbuf (pixbuf);
 	  gtk_widget_show (image);
+#ifdef HAVE_XTSOL
+      if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+	image = window_menu_create_label_indicator (win_task->window, image);
+#endif /*HAVE_XTSOL*/	  
 	  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (menu_item),
 					 image);
 	  g_object_unref (pixbuf);
@@ -3352,6 +3368,15 @@
   text = wnck_task_get_text (task, TRUE, TRUE);
   if (text != NULL)
     {
+#ifdef HAVE_XTSOL
+    if (_wnck_use_trusted_extensions () == TRUE)
+        trusted_tooltips_set_tip (task->tasklist->priv->tooltips,
+                                task->button,
+                                 text,
+                                 task->window ? wnck_window_get_label_human_readable (task->window) : "",
+                                 task->window ? wnck_window_get_label_color (task->window) : NULL,
+                                 NULL);
+#endif /* HAVE_XTSOL */
       gtk_label_set_text (GTK_LABEL (task->label), text);
       if (wnck_task_get_needs_attention (task))
         {
@@ -3812,7 +3837,24 @@
   g_free (text);
   
   text = wnck_task_get_text (task, FALSE, FALSE);
+#ifdef HAVE_XTSOL
+  if (_wnck_use_trusted_extensions () == TRUE)
+    {
+      if (task->window)
+        {
+         trusted_tooltips_set_tip (task->tasklist->priv->tooltips,
+                                   task->button,
+                                   text,
+                                   wnck_window_get_label_human_readable (task->window),
+                                   wnck_window_get_label_color (task->window),
+                                   NULL);
+        }
+    else
+      trusted_tooltips_set_tip (task->tasklist->priv->tooltips, task->button, text, "Hum No Label", NULL, NULL);
+  }
+#else
   gtk_widget_set_tooltip_text (task->button, text);
+#endif /*HAVE_XTSOL*/
   g_free (text);
   
   /* Set up signals */
@@ -4182,6 +4224,48 @@
 #endif
 }
 
+#ifdef HAVE_XTSOL
+static void
+draw_trusted_label (GtkWidget* widget, WnckTask *task)
+{
+  GtkStyle *style;
+  int x_offset;
+  ConstraintImage *cimage;
+  GdkRectangle area;
+
+  style = task->button->style;
+  /* get the width of the icon and the padding */
+  x_offset = task->image->allocation.width + (style->xthickness *2);
+
+  area.x = widget->allocation.x + x_offset;
+  area.y = widget->allocation.y + 2;
+  area.width = widget->allocation.width - x_offset;
+  area.height = task->label->allocation.y -task->button->allocation.y;
+
+  cimage = get_highlight_stripe ((char*)wnck_window_get_label (task->window),
+                                wnck_window_get_label_color (task->window));
+
+  if (cimage)
+    libgnome_tsol_constraint_image_render (cimage, widget->window,
+                                          NULL, &area,
+                                          FALSE,
+                                          area.x,
+                                          area.y,
+                                          area.width,
+                                          area.height);
+}
+
+
+gboolean
+wnck_task_class_expose (GtkWidget        *widget,
+                       GdkEventExpose   *event,
+                       gpointer          data)
+{
+  draw_trusted_label (widget, (WnckTask*) data);
+  return FALSE;
+}
+#endif /* HAVE_XTSOL */
+
 static WnckTask *
 wnck_task_new_from_window (WnckTasklist *tasklist,
 			   WnckWindow   *window)
@@ -4197,6 +4281,14 @@
   
   wnck_task_create_widgets (task, tasklist->priv->relief);
 
+#ifdef HAVE_XTSOL
+  if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+    g_signal_connect_object (task->button, "expose_event",
+                            G_CALLBACK (wnck_task_class_expose),
+                            G_OBJECT (task),
+                            G_CONNECT_AFTER);
+#endif /* HAVE_XTSOL */
+
   remove_startup_sequences_for_window (tasklist, window);
   
   return task;
diff -urN libwnck.orig/libwnck/trusted-tooltips.c libwnck.new/libwnck/trusted-tooltips.c
--- libwnck.orig/libwnck/trusted-tooltips.c	1970-01-01 01:00:00.000000000 +0100
+++ libwnck.new/libwnck/trusted-tooltips.c	2008-08-06 23:43:40.105541000 +0100
@@ -0,0 +1,916 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ *
+ * Modified for trusted JDS by Erwann Chenede - <erwann.chenede@sun.com> 2005
+ * Copyright (C) Sun Microsystems 2005 
+ */
+
+#include <config.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#ifdef HAVE_XTSOL
+#include "trusted-tooltips.h"
+#include "workspace.h"
+#include <wnck-tsol.h>
+#include <gtk/gtk.h>
+
+
+#define DEFAULT_DELAY 500           /* Default delay in ms */
+#define STICKY_DELAY 0              /* Delay before popping up next tip
+                                     * if we're sticky
+                                     */
+#define STICKY_REVERT_DELAY 1000    /* Delay before sticky tooltips revert
+				     * to normal
+                                     */
+
+static void trusted_tooltips_class_init        (TrustedTooltipsClass *klass);
+static void trusted_tooltips_init              (TrustedTooltips      *tooltips);
+static void trusted_tooltips_destroy           (GtkObject        *object);
+
+static void trusted_tooltips_event_handler     (GtkWidget   *widget,
+                                            GdkEvent    *event);
+static void trusted_tooltips_widget_unmap      (GtkWidget   *widget,
+                                            gpointer     data);
+static void trusted_tooltips_widget_remove     (GtkWidget   *widget,
+                                            gpointer     data);
+static void trusted_tooltips_set_active_widget (TrustedTooltips *tooltips,
+                                            GtkWidget   *widget);
+static gint trusted_tooltips_timeout           (gpointer     data);
+
+static gint trusted_tooltips_paint_window      (TrustedTooltips *tooltips);
+static void trusted_tooltips_draw_tips         (TrustedTooltips *tooltips);
+static void trusted_tooltips_unset_tip_window  (TrustedTooltips *tooltips);
+
+static gboolean get_keyboard_mode          (GtkWidget   *widget);
+
+static GtkObjectClass *parent_class;
+static const gchar  tooltips_data_key[] = "_TrustedTooltipsData";
+static const gchar  tooltips_info_key[] = "_TrustedTooltipsInfo";
+
+GType
+trusted_tooltips_get_type (void)
+{
+  static GType tooltips_type = 0;
+
+  if (!tooltips_type)
+    {
+      static const GTypeInfo tooltips_info =
+      {
+	sizeof (TrustedTooltipsClass),
+	NULL,		/* base_init */
+	NULL,		/* base_finalize */
+	(GClassInitFunc) trusted_tooltips_class_init,
+	NULL,		/* class_finalize */
+	NULL,		/* class_data */
+	sizeof (TrustedTooltips),
+	0,		/* n_preallocs */
+	(GInstanceInitFunc) trusted_tooltips_init,
+      };
+
+      tooltips_type = g_type_register_static (GTK_TYPE_OBJECT, "TrustedTooltips",
+					      &tooltips_info, 0);
+    }
+
+  return tooltips_type;
+}
+
+static void
+trusted_tooltips_class_init (TrustedTooltipsClass *class)
+{
+  GtkObjectClass *object_class;
+
+  object_class = (GtkObjectClass*) class;
+
+  parent_class = g_type_class_peek_parent (class);
+
+  object_class->destroy = trusted_tooltips_destroy;
+}
+
+static void
+trusted_tooltips_init (TrustedTooltips *tooltips)
+{
+  tooltips->tip_window = NULL;
+  tooltips->active_tips_data = NULL;
+  tooltips->tips_data_list = NULL;
+  
+  tooltips->delay = DEFAULT_DELAY;
+  tooltips->enabled = TRUE;
+  tooltips->timer_tag = 0;
+  tooltips->use_sticky_delay = FALSE;
+  tooltips->last_popdown.tv_sec = -1;
+  tooltips->last_popdown.tv_usec = -1;
+  tooltips->pager = NULL;
+}
+
+TrustedTooltips *
+trusted_tooltips_new (void)
+{
+  return g_object_new (TRUSTED_TOOLTIPS_TYPE, NULL);
+}
+
+static void
+trusted_tooltips_destroy_data (TrustedTooltipsData *tooltipsdata)
+{
+  g_free (tooltipsdata->tip_text);
+  g_free (tooltipsdata->trusted_label);
+  g_free (tooltipsdata->tip_private);
+
+  g_signal_handlers_disconnect_by_func (tooltipsdata->widget,
+				        (gpointer)trusted_tooltips_event_handler,
+					tooltipsdata);
+  g_signal_handlers_disconnect_by_func (tooltipsdata->widget,
+					(gpointer)trusted_tooltips_widget_unmap,
+					tooltipsdata);
+  g_signal_handlers_disconnect_by_func (tooltipsdata->widget,
+					(gpointer)trusted_tooltips_widget_remove,
+					tooltipsdata);
+
+  g_object_set_data (G_OBJECT (tooltipsdata->widget), tooltips_data_key, NULL);
+  g_object_unref (tooltipsdata->widget);
+  g_free (tooltipsdata);
+}
+
+static void
+tip_window_display_closed (GdkDisplay  *display,
+			   gboolean     was_error,
+			   TrustedTooltips *tooltips)
+{
+  trusted_tooltips_unset_tip_window (tooltips);
+}
+
+static void
+disconnect_tip_window_display_closed (TrustedTooltips *tooltips)
+{
+  g_signal_handlers_disconnect_by_func (gtk_widget_get_display (tooltips->tip_window),
+					(gpointer) tip_window_display_closed,
+					tooltips);
+}
+
+static void
+trusted_tooltips_unset_tip_window (TrustedTooltips *tooltips)
+{
+  if (tooltips->tip_window)
+    {
+      disconnect_tip_window_display_closed (tooltips);
+      
+      gtk_widget_destroy (tooltips->tip_window);
+      tooltips->tip_window = NULL;
+    }
+}
+
+static void
+trusted_tooltips_destroy (GtkObject *object)
+{
+  TrustedTooltips *tooltips = TRUSTED_TOOLTIPS (object);
+  GList *current;
+  TrustedTooltipsData *tooltipsdata;
+
+  g_return_if_fail (tooltips != NULL);
+
+  if (tooltips->timer_tag)
+    {
+      g_source_remove (tooltips->timer_tag);
+      tooltips->timer_tag = 0;
+    }
+
+  if (tooltips->tips_data_list != NULL)
+    {
+      current = g_list_first (tooltips->tips_data_list);
+      while (current != NULL)
+	{
+	  tooltipsdata = (TrustedTooltipsData*) current->data;
+	  current = current->next;
+	  trusted_tooltips_widget_remove (tooltipsdata->widget, tooltipsdata);
+	}
+    }
+
+  trusted_tooltips_unset_tip_window (tooltips);
+
+  GTK_OBJECT_CLASS (parent_class)->destroy (object);
+}
+
+static void
+trusted_tooltips_update_screen (TrustedTooltips *tooltips,
+			    gboolean     new_window)
+{
+  gboolean screen_changed = FALSE;
+  
+  if (tooltips->active_tips_data &&
+      tooltips->active_tips_data->widget)
+    {
+      GdkScreen *screen = gtk_widget_get_screen (tooltips->active_tips_data->widget);
+
+      screen_changed = (screen != gtk_widget_get_screen (tooltips->tip_window));
+
+      if (screen_changed)
+	{
+	  if (!new_window)
+	    disconnect_tip_window_display_closed (tooltips);
+      
+	  gtk_window_set_screen (GTK_WINDOW (tooltips->tip_window), screen);
+	}
+    }
+
+  if (screen_changed || new_window)
+    g_signal_connect (gtk_widget_get_display (tooltips->tip_window), "closed",
+		      G_CALLBACK (tip_window_display_closed), tooltips);
+
+}
+
+void
+trusted_tooltips_force_window (TrustedTooltips *tooltips)
+{
+  g_return_if_fail (IS_TRUSTED_TOOLTIPS (tooltips));
+
+  if (!tooltips->tip_window)
+    {
+      GtkWidget * vbox;
+
+      tooltips->tip_window = gtk_window_new (GTK_WINDOW_POPUP);
+      trusted_tooltips_update_screen (tooltips, TRUE);
+      gtk_widget_set_app_paintable (tooltips->tip_window, TRUE);
+      gtk_window_set_resizable (GTK_WINDOW (tooltips->tip_window), FALSE);
+      gtk_widget_set_name (tooltips->tip_window, "gtk-tooltips");
+      gtk_container_set_border_width (GTK_CONTAINER (tooltips->tip_window), 2);
+
+      g_signal_connect_swapped (tooltips->tip_window,
+				"expose_event",
+				G_CALLBACK (trusted_tooltips_paint_window), 
+				tooltips);
+
+      tooltips->tip_label = gtk_label_new (NULL);
+      gtk_label_set_line_wrap (GTK_LABEL (tooltips->tip_label), FALSE);
+      gtk_misc_set_alignment (GTK_MISC (tooltips->tip_label), 0.5, 0.5);
+      gtk_widget_show (tooltips->tip_label);
+
+      tooltips->tip_trusted_label = gtk_label_new (NULL);
+      gtk_label_set_line_wrap (GTK_LABEL (tooltips->tip_trusted_label), FALSE);
+      gtk_misc_set_alignment (GTK_MISC (tooltips->tip_trusted_label), 0.5, 0.5);
+      gtk_widget_show (tooltips->tip_trusted_label);
+
+      vbox = gtk_vbox_new (FALSE, 1);
+      tooltips->event = gtk_event_box_new ();
+
+      gtk_container_add (GTK_CONTAINER (tooltips->event), tooltips->tip_trusted_label);
+      
+      gtk_container_add (GTK_CONTAINER (vbox), tooltips->event);
+
+      gtk_container_add (GTK_CONTAINER (vbox), tooltips->tip_label);
+      gtk_container_add (GTK_CONTAINER (tooltips->tip_window), vbox);
+
+      gtk_widget_show (vbox);
+      gtk_widget_show (tooltips->event);
+
+      g_signal_connect (tooltips->tip_window,
+			"destroy",
+			G_CALLBACK (gtk_widget_destroyed),
+			&tooltips->tip_window);
+    }
+}
+
+void
+trusted_tooltips_enable (TrustedTooltips *tooltips)
+{
+  g_return_if_fail (tooltips != NULL);
+
+  tooltips->enabled = TRUE;
+}
+
+void
+trusted_tooltips_disable (TrustedTooltips *tooltips)
+{
+  g_return_if_fail (tooltips != NULL);
+
+  trusted_tooltips_set_active_widget (tooltips, NULL);
+
+  tooltips->enabled = FALSE;
+}
+
+void
+trusted_tooltips_set_delay (TrustedTooltips *tooltips,
+                        guint         delay)
+{
+  g_return_if_fail (tooltips != NULL);
+
+  tooltips->delay = delay;
+}
+
+TrustedTooltipsData*
+trusted_tooltips_data_get (GtkWidget       *widget)
+{
+  g_return_val_if_fail (widget != NULL, NULL);
+
+  return g_object_get_data (G_OBJECT (widget), tooltips_data_key);
+}
+
+void
+trusted_tooltips_set_tip (TrustedTooltips *tooltips,
+		      GtkWidget   *widget,
+		      const gchar *tip_text,
+		      const gchar *trusted_label,
+		      GdkColor	  *trusted_color,
+		      const gchar *tip_private)
+{
+  TrustedTooltipsData *tooltipsdata;
+
+  g_return_if_fail (IS_TRUSTED_TOOLTIPS (tooltips));
+  g_return_if_fail (widget != NULL);
+
+  tooltipsdata = trusted_tooltips_data_get (widget);
+
+  if (!tip_text)
+    {
+      if (tooltipsdata)
+	trusted_tooltips_widget_remove (tooltipsdata->widget, tooltipsdata);
+      return;
+    }
+  
+  if (tooltips->active_tips_data 
+      && tooltips->active_tips_data->widget == widget
+      && GTK_WIDGET_DRAWABLE (tooltips->active_tips_data->widget))
+    {
+      g_free (tooltipsdata->tip_text);
+      g_free (tooltipsdata->tip_private);
+
+      tooltipsdata->tip_text = g_strdup (tip_text);
+      tooltipsdata->tip_private = g_strdup (tip_private);
+      
+      trusted_tooltips_draw_tips (tooltips);
+    }
+  else 
+    {
+      g_object_ref (widget);
+      
+      if (tooltipsdata)
+        trusted_tooltips_widget_remove (tooltipsdata->widget, tooltipsdata);
+      
+      tooltipsdata = g_new0 (TrustedTooltipsData, 1);
+      
+      tooltipsdata->tooltips = tooltips;
+      tooltipsdata->widget = widget;
+
+      tooltipsdata->tip_text = g_strdup (tip_text);
+      tooltipsdata->trusted_label = g_strdup (trusted_label);
+      tooltipsdata->tip_private = g_strdup (tip_private);
+      if (trusted_color)
+	tooltipsdata->trusted_color = trusted_color;
+
+      tooltips->tips_data_list = g_list_append (tooltips->tips_data_list,
+                                                tooltipsdata);
+      g_signal_connect_after (widget, "event-after",
+                              G_CALLBACK (trusted_tooltips_event_handler),
+			      tooltipsdata);
+
+      g_object_set_data (G_OBJECT (widget), tooltips_data_key,
+                         tooltipsdata);
+
+      g_signal_connect (widget, "unmap",
+			G_CALLBACK (trusted_tooltips_widget_unmap),
+			tooltipsdata);
+
+      g_signal_connect (widget, "unrealize",
+			G_CALLBACK (trusted_tooltips_widget_unmap),
+			tooltipsdata);
+
+      g_signal_connect (widget, "destroy",
+                        G_CALLBACK (trusted_tooltips_widget_remove),
+			tooltipsdata);
+    }
+}
+
+static gint
+trusted_tooltips_paint_window (TrustedTooltips *tooltips)
+{
+  GtkRequisition req;
+
+  gtk_widget_size_request (tooltips->tip_window, &req);
+  gtk_paint_flat_box (tooltips->tip_window->style, tooltips->tip_window->window,
+		      GTK_STATE_NORMAL, GTK_SHADOW_OUT, 
+		      NULL, GTK_WIDGET(tooltips->tip_window), "tooltip",
+		      0, 0, req.width, req.height);
+
+  return FALSE;
+}
+
+static void
+trusted_tooltips_draw_tips (TrustedTooltips *tooltips)
+{
+  GtkRequisition requisition;
+  GtkWidget *widget;
+  GtkStyle *style;
+  gint x, y, w, h;
+  TrustedTooltipsData *data;
+  gboolean keyboard_mode;
+  GdkScreen *screen;
+  GdkScreen *pointer_screen;
+  gint monitor_num, px, py;
+  GdkRectangle monitor;
+
+  if (!tooltips->tip_window)
+    trusted_tooltips_force_window (tooltips);
+  else if (GTK_WIDGET_VISIBLE (tooltips->tip_window))
+    g_get_current_time (&tooltips->last_popdown);
+
+  gtk_widget_ensure_style (tooltips->tip_window);
+  style = tooltips->tip_window->style;
+  
+  widget = tooltips->active_tips_data->widget;
+  g_object_set_data (G_OBJECT (tooltips->tip_window), tooltips_info_key,
+                     tooltips);
+
+  keyboard_mode = get_keyboard_mode (widget);
+
+  trusted_tooltips_update_screen (tooltips, FALSE);
+  
+  screen = gtk_widget_get_screen (widget);
+
+  data = tooltips->active_tips_data;
+
+  if (tooltips->pager) /* pager special case */
+    {
+      char *colorname;
+      int error;
+      GdkColor label_color;
+      m_label_t *mlabel = NULL;
+      WnckWorkspace *tip_ws = g_object_get_data (G_OBJECT (tooltips->pager), 
+						 "tip_ws");
+						 
+      const char *label = wnck_workspace_get_label (tip_ws);
+      
+      gtk_label_set_text (GTK_LABEL (tooltips->tip_label), 
+			  wnck_workspace_get_name (tip_ws)); 
+      
+      if (_wnck_use_trusted_extensions ())
+	{
+	  if (label != NULL && 
+	      (error = libtsol_str_to_label (label, &mlabel, MAC_LABEL, 
+				     L_NO_CORRECTION, &error)) == 0) 
+	    {
+	      GdkPixbuf *pb;
+	      guint32 rgba;
+	      char *readable_label;
+	      
+	      error = libtsol_label_to_str (mlabel, &colorname, M_COLOR, DEF_NAMES);
+	      
+#define DEFAULT_COLOR	"white"	  
+	      if (colorname == NULL)
+		colorname = g_strdup(DEFAULT_COLOR);
+	      
+	      gdk_color_parse ((const char*)colorname, &label_color);
+	      
+	      g_free (colorname);
+	      
+	      
+	      readable_label = wnck_workspace_get_human_readable_label (tip_ws);
+	      
+	      gtk_label_set_text (GTK_LABEL (tooltips->tip_trusted_label), readable_label);
+	      
+	      g_free (readable_label);
+	      
+	      gtk_widget_modify_bg (tooltips->event, GTK_STATE_NORMAL, &label_color);
+	      
+	      gtk_widget_show (tooltips->event);
+	    }
+	  else /* failed call to libtsol_label_to_str */
+	    gtk_widget_hide (tooltips->event);
+	}
+      else /* not using trusted_extensions */
+	gtk_widget_hide (tooltips->event);
+    }
+  else
+    {
+      gtk_label_set_text (GTK_LABEL (tooltips->tip_label), data->tip_text);
+      gtk_label_set_text (GTK_LABEL (tooltips->tip_trusted_label), data->trusted_label);
+      gtk_widget_modify_bg (tooltips->event, GTK_STATE_NORMAL, data->trusted_color);
+      if (data->trusted_color == NULL)
+	gtk_widget_hide (tooltips->event);
+      else
+	gtk_widget_show (tooltips->event);
+    }
+    
+ 
+  gtk_widget_size_request (tooltips->tip_window, &requisition);
+  w = requisition.width;
+  h = requisition.height;
+
+  gdk_window_get_origin (widget->window, &x, &y);
+  if (GTK_WIDGET_NO_WINDOW (widget))
+    {
+      x += widget->allocation.x;
+      y += widget->allocation.y;
+    }
+
+  x += widget->allocation.width / 2;
+    
+  if (!keyboard_mode)
+    gdk_window_get_pointer (gdk_screen_get_root_window (screen),
+			    &x, NULL, NULL);
+
+  x -= (w / 2 + 4);
+
+  gdk_display_get_pointer (gdk_screen_get_display (screen),
+			   &pointer_screen, &px, &py, NULL);
+  if (pointer_screen != screen) 
+    {
+      px = x;
+      py = y;
+    }
+  monitor_num = gdk_screen_get_monitor_at_point (screen, px, py);
+  gdk_screen_get_monitor_geometry (screen, monitor_num, &monitor);
+
+  if ((x + w) > monitor.x + monitor.width)
+    x -= (x + w) - (monitor.x + monitor.width);
+  else if (x < monitor.x)
+    x = monitor.x;
+
+  if ((y + h + widget->allocation.height + 4) > monitor.y + monitor.height)
+    y = y - h - 4;
+  else
+    y = y + widget->allocation.height + 4;
+
+  gtk_window_move (GTK_WINDOW (tooltips->tip_window), x, y);
+  gtk_widget_show (tooltips->tip_window);
+}
+
+static gint
+trusted_tooltips_timeout (gpointer data)
+{
+  TrustedTooltips *tooltips = (TrustedTooltips *) data;
+
+  GDK_THREADS_ENTER ();
+  
+  if (tooltips->active_tips_data != NULL &&
+      GTK_WIDGET_DRAWABLE (tooltips->active_tips_data->widget))
+    trusted_tooltips_draw_tips (tooltips);
+
+  GDK_THREADS_LEAVE ();
+
+  return FALSE;
+}
+
+static void
+trusted_tooltips_set_active_widget (TrustedTooltips *tooltips,
+                                GtkWidget   *widget)
+{
+  if (tooltips->tip_window)
+    {
+      if (GTK_WIDGET_VISIBLE (tooltips->tip_window))
+	g_get_current_time (&tooltips->last_popdown);
+      gtk_widget_hide (tooltips->tip_window);
+    }
+  if (tooltips->timer_tag)
+    {
+      g_source_remove (tooltips->timer_tag);
+      tooltips->timer_tag = 0;
+    }
+  
+  tooltips->active_tips_data = NULL;
+  
+  if (widget)
+    {
+      GList *list;
+      
+      for (list = tooltips->tips_data_list; list; list = list->next)
+	{
+	  TrustedTooltipsData *tooltipsdata;
+	  
+	  tooltipsdata = list->data;
+	  
+	  if (tooltipsdata->widget == widget &&
+	      GTK_WIDGET_DRAWABLE (widget))
+	    {
+	      tooltips->active_tips_data = tooltipsdata;
+	      break;
+	    }
+	}
+    }
+  else
+    {
+      tooltips->use_sticky_delay = FALSE;
+    }
+}
+
+static void
+trusted_tooltips_show_tip (GtkWidget *widget)
+{
+  TrustedTooltipsData *tooltipsdata;
+
+  tooltipsdata = trusted_tooltips_data_get (widget);
+
+  if (tooltipsdata &&
+      (!tooltipsdata->tooltips->active_tips_data ||
+       tooltipsdata->tooltips->active_tips_data->widget != widget))
+    {
+      trusted_tooltips_set_active_widget (tooltipsdata->tooltips, widget);
+      trusted_tooltips_draw_tips (tooltipsdata->tooltips);
+    }
+}
+
+static void
+trusted_tooltips_hide_tip (GtkWidget *widget)
+{
+  TrustedTooltipsData *tooltipsdata;
+
+  tooltipsdata = trusted_tooltips_data_get (widget);
+
+  if (tooltipsdata &&
+      (tooltipsdata->tooltips->active_tips_data &&
+       tooltipsdata->tooltips->active_tips_data->widget == widget))
+    trusted_tooltips_set_active_widget (tooltipsdata->tooltips, NULL);
+}
+
+static gboolean
+trusted_tooltips_recently_shown (TrustedTooltips *tooltips)
+{
+  GTimeVal now;
+  glong msec;
+  
+  g_get_current_time (&now);
+  msec = (now.tv_sec  - tooltips->last_popdown.tv_sec) * 1000 +
+	  (now.tv_usec - tooltips->last_popdown.tv_usec) / 1000;
+  return (msec < STICKY_REVERT_DELAY);
+}
+
+static gboolean
+get_keyboard_mode (GtkWidget *widget)
+{
+  GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
+  if (GTK_IS_WINDOW (toplevel))
+    return GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (toplevel), "gtk-tooltips-keyboard-mode"));
+  else
+    return FALSE;
+}
+
+static void
+start_keyboard_mode (GtkWidget *widget)
+{
+  GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
+  if (GTK_IS_WINDOW (toplevel))
+    {
+      GtkWidget *focus = GTK_WINDOW (toplevel)->focus_widget;
+
+      g_object_set_data (G_OBJECT (toplevel), "gtk-tooltips-keyboard-mode", GUINT_TO_POINTER (TRUE));
+
+      if (focus)
+	trusted_tooltips_show_tip (focus);
+    }
+}
+
+static void
+stop_keyboard_mode (GtkWidget *widget)
+{
+  GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
+  if (GTK_IS_WINDOW (toplevel))
+    {
+      GtkWidget *focus = GTK_WINDOW (toplevel)->focus_widget;
+      if (focus)
+	trusted_tooltips_hide_tip (focus);
+      
+      g_object_set_data (G_OBJECT (toplevel), "gtk-tooltips-keyboard-mode", GUINT_TO_POINTER (FALSE));
+    }
+}
+
+static void
+trusted_tooltips_start_delay (TrustedTooltips *tooltips,
+			  GtkWidget   *widget)
+{
+  TrustedTooltipsData *old_tips_data;
+  
+  old_tips_data = tooltips->active_tips_data;
+  if (tooltips->enabled &&
+      (!old_tips_data || old_tips_data->widget != widget))
+    {
+      guint delay;
+      
+      trusted_tooltips_set_active_widget (tooltips, widget);
+      
+      if (tooltips->use_sticky_delay &&
+	  trusted_tooltips_recently_shown (tooltips))
+	delay = STICKY_DELAY;
+      else
+	delay = tooltips->delay;
+      tooltips->timer_tag = g_timeout_add (delay,
+					   trusted_tooltips_timeout,
+					   (gpointer) tooltips);
+    }
+}
+
+static void
+trusted_tooltips_event_handler (GtkWidget *widget,
+                            GdkEvent  *event)
+{
+  TrustedTooltips *tooltips;
+  TrustedTooltipsData *old_tips_data;
+  GtkWidget *event_widget;
+  gboolean keyboard_mode = get_keyboard_mode (widget);
+
+
+  if ((event->type == GDK_LEAVE_NOTIFY || event->type == GDK_ENTER_NOTIFY) &&
+      event->crossing.detail == GDK_NOTIFY_INFERIOR)
+    return;
+  
+  old_tips_data = trusted_tooltips_data_get (widget);
+  tooltips = old_tips_data->tooltips;
+
+  if (keyboard_mode)
+    {
+      switch (event->type)
+	{
+	case GDK_FOCUS_CHANGE:
+	  if (event->focus_change.in)
+	    trusted_tooltips_show_tip (widget);
+	  else
+	    trusted_tooltips_hide_tip (widget);
+	  break;
+	default:
+	  break;
+	}
+    }
+  else
+    {
+      if (event->type != GDK_KEY_PRESS && event->type != GDK_KEY_RELEASE)
+	{
+	  event_widget = gtk_get_event_widget (event);
+	  if (event_widget != widget)
+	    return;
+	}
+
+      if (tooltips->pager != NULL) /* handler pager tooltips special case */
+	{
+	  static WnckWorkspace *current = NULL;
+	  if (event->type == GDK_MOTION_NOTIFY || event->type == GDK_ENTER_NOTIFY)
+	    {
+	      WnckWorkspace *tip_ws = g_object_get_data (G_OBJECT (tooltips->pager), 
+							 "tip_ws");
+
+	      if (current != tip_ws) 
+		{
+		  /* do something only if the workspace changed */
+		  current = tip_ws;
+		  trusted_tooltips_set_active_widget (tooltips, NULL);
+		  trusted_tooltips_start_delay (tooltips, widget);
+		}
+	    }
+	  if (event->type == GDK_LEAVE_NOTIFY)
+	    {
+	      trusted_tooltips_set_active_widget (tooltips, NULL);
+	      current = NULL;
+	    }
+	} 
+      else
+	{
+	  switch (event->type)
+	    {
+	    case GDK_EXPOSE:
+	      /* do nothing */
+	      break;
+	    case GDK_ENTER_NOTIFY:
+	      if (!(GTK_IS_MENU_ITEM (widget) && GTK_MENU_ITEM (widget)->submenu))
+		trusted_tooltips_start_delay (tooltips, widget);
+	      break;
+	      
+	    case GDK_LEAVE_NOTIFY:
+	      {
+		gboolean use_sticky_delay;
+		
+		use_sticky_delay = tooltips->tip_window &&
+		  GTK_WIDGET_VISIBLE (tooltips->tip_window);
+		trusted_tooltips_set_active_widget (tooltips, NULL);
+		tooltips->use_sticky_delay = use_sticky_delay;
+	      }
+	      break;
+
+	    case GDK_MOTION_NOTIFY:
+	      /* Handle menu items specially ... pend popup for each motion
+	       * on other widgets, we ignore motion.
+	       */
+	      if (GTK_IS_MENU_ITEM (widget) && !GTK_MENU_ITEM (widget)->submenu)
+		{
+		  /* Completely evil hack to make sure we get the LEAVE_NOTIFY
+		   */
+		  /* GTK_PRIVATE_SET_FLAG (widget, GTK_LEAVE_PENDING); */
+		  trusted_tooltips_set_active_widget (tooltips, NULL);
+		  trusted_tooltips_start_delay (tooltips, widget);
+		  break;
+		}
+	      break;		/* ignore */
+	    case GDK_BUTTON_PRESS:
+	    case GDK_BUTTON_RELEASE:
+	    case GDK_KEY_PRESS:
+	    case GDK_KEY_RELEASE:
+	    case GDK_PROXIMITY_IN:
+	    case GDK_SCROLL:
+	      trusted_tooltips_set_active_widget (tooltips, NULL);
+	      break;
+	    default:
+	      break;
+	    }
+	}
+    }
+}
+
+static void
+trusted_tooltips_widget_unmap (GtkWidget *widget,
+			   gpointer   data)
+{
+  TrustedTooltipsData *tooltipsdata = (TrustedTooltipsData *)data;
+  TrustedTooltips *tooltips = tooltipsdata->tooltips;
+  
+  if (tooltips->active_tips_data &&
+      (tooltips->active_tips_data->widget == widget))
+    trusted_tooltips_set_active_widget (tooltips, NULL);
+}
+
+static void
+trusted_tooltips_widget_remove (GtkWidget *widget,
+			    gpointer   data)
+{
+  TrustedTooltipsData *tooltipsdata = (TrustedTooltipsData*) data;
+  TrustedTooltips *tooltips = tooltipsdata->tooltips;
+
+  trusted_tooltips_widget_unmap (widget, data);
+  tooltips->tips_data_list = g_list_remove (tooltips->tips_data_list,
+					    tooltipsdata);
+  trusted_tooltips_destroy_data (tooltipsdata);
+}
+
+void
+_trusted_tooltips_toggle_keyboard_mode (GtkWidget *widget)
+{
+  if (get_keyboard_mode (widget))
+    stop_keyboard_mode (widget);
+  else
+    start_keyboard_mode (widget);
+}
+
+/**
+ * trusted_tooltips_get_info_from_tip_window:
+ * @tip_window: a #GtkWindow 
+ * @tooltips: the return location for the tooltips which are displayed 
+ *    in @tip_window, or %NULL
+ * @current_widget: the return location for the widget whose tooltips 
+ *    are displayed, or %NULL
+ * 
+ * Determines the tooltips and the widget they belong to from the window in 
+ * which they are displayed. 
+ *
+ * This function is mostly intended for use by accessibility technologies;
+ * applications should have little use for it.
+ * 
+ * Return value: %TRUE if @tip_window is displaying tooltips, otherwise %FALSE.
+ *
+ * Since: 2.4
+ **/
+gboolean
+trusted_tooltips_get_info_from_tip_window (GtkWindow    *tip_window,
+                                       TrustedTooltips **tooltips,
+                                       GtkWidget   **current_widget)
+{
+  TrustedTooltips  *current_tooltips;  
+  gboolean has_tips;
+
+  g_return_val_if_fail (GTK_IS_WINDOW (tip_window), FALSE);
+
+  current_tooltips = g_object_get_data (G_OBJECT (tip_window), tooltips_info_key);
+
+  has_tips = current_tooltips != NULL;
+
+  if (tooltips)
+    *tooltips = current_tooltips;
+  if (current_widget)
+    *current_widget = has_tips ? current_tooltips->active_tips_data->widget : NULL;
+
+  return has_tips;
+}
+void
+trusted_tooltips_set_pager (TrustedTooltips *tooltips,
+			    WnckPager *pager)
+{
+   tooltips->pager = pager;
+}
+#endif /* HAVE_XTSOL */
+#define __TRUSTED_TOOLTIPS_C__
diff -urN libwnck.orig/libwnck/trusted-tooltips.h libwnck.new/libwnck/trusted-tooltips.h
--- libwnck.orig/libwnck/trusted-tooltips.h	1970-01-01 01:00:00.000000000 +0100
+++ libwnck.new/libwnck/trusted-tooltips.h	2008-08-06 23:43:40.108722000 +0100
@@ -0,0 +1,120 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#ifndef __TRUSTED_TOOLTIPS_H__
+#define __TRUSTED_TOOLTIPS_H__
+
+#include <gtk/gtkwidget.h>
+#include <gtk/gtkwindow.h>
+#include "pager.h"
+
+G_BEGIN_DECLS
+
+#define TRUSTED_TOOLTIPS_TYPE                  (trusted_tooltips_get_type ())
+#define TRUSTED_TOOLTIPS(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), TRUSTED_TOOLTIPS_TYPE, TrustedTooltips))
+#define TRUSTED_TOOLTIPS_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), TRUSTED_TOOLTIPS_TYPE, TrustedTooltipsClass))
+#define IS_TRUSTED_TOOLTIPS(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TRUSTED_TOOLTIPS_TYPE))
+#define IS_TRUSTED_TOOLTIPS_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), TRUSTED_TOOLTIPS_TYPE))
+#define TRUSTED_TOOLTIPS_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), TRUSTED_TOOLTIPS_TYPE, TrustedTooltipsClass))
+
+
+typedef struct _TrustedTooltips	 TrustedTooltips;
+typedef struct _TrustedTooltipsClass TrustedTooltipsClass;
+typedef struct _TrustedTooltipsData	 TrustedTooltipsData;
+
+struct _TrustedTooltipsData
+{
+  TrustedTooltips *tooltips;
+  GtkWidget *widget;
+  gchar *tip_text;
+  gchar *trusted_label;
+  GdkColor  *trusted_color;
+  gchar *tip_private;
+};
+
+struct _TrustedTooltips
+{
+  GtkObject parent_instance;
+
+  GtkWidget *tip_window;
+  GtkWidget *tip_label;
+  GtkWidget *tip_trusted_label;
+  GtkWidget *event;
+  TrustedTooltipsData *active_tips_data;
+  GList *tips_data_list;
+
+  guint   delay : 30;
+  guint	  enabled : 1;
+  guint   have_grab : 1;
+  guint   use_sticky_delay : 1;
+  gint	  timer_tag;
+  GTimeVal last_popdown;
+  WnckPager *pager;
+};
+
+struct _TrustedTooltipsClass
+{
+  GtkObjectClass parent_class;
+
+  /* Padding for future expansion */
+  void (*_gtk_reserved1) (void);
+  void (*_gtk_reserved2) (void);
+  void (*_gtk_reserved3) (void);
+  void (*_gtk_reserved4) (void);
+};
+
+GType		 trusted_tooltips_get_type	   (void) G_GNUC_CONST;
+TrustedTooltips*	 trusted_tooltips_new	   (void);
+
+void		 trusted_tooltips_enable	   (TrustedTooltips   *tooltips);
+void		 trusted_tooltips_disable	   (TrustedTooltips   *tooltips);
+#ifndef GTK_DISABLE_DEPRECATED
+void		 trusted_tooltips_set_delay	   (TrustedTooltips   *tooltips,
+					    guint	   delay);
+#endif /* GTK_DISABLE_DEPRECATED */
+void		 trusted_tooltips_set_tip	   (TrustedTooltips   *tooltips,
+						    GtkWidget	  *widget,
+						    const gchar   *tip_text,
+						    const gchar   *trusted_label,
+						    GdkColor	  *trusted_color,
+						    const gchar   *tip_private);
+TrustedTooltipsData* trusted_tooltips_data_get	   (GtkWidget	  *widget);
+void             trusted_tooltips_force_window (TrustedTooltips   *tooltips);
+
+
+void             _trusted_tooltips_toggle_keyboard_mode (GtkWidget *widget);
+
+gboolean         trusted_tooltips_get_info_from_tip_window (GtkWindow    *tip_window,
+                                                        TrustedTooltips **tooltips,
+                                                        GtkWidget   **current_widget);
+
+void		 trusted_tooltips_set_pager	  (TrustedTooltips *tooltips,
+						   WnckPager *pager);
+
+
+G_END_DECLS
+
+#endif /* __TRUSTED_TOOLTIPS_H__ */
diff -urN libwnck.orig/libwnck/tsol-pics.h libwnck.new/libwnck/tsol-pics.h
--- libwnck.orig/libwnck/tsol-pics.h	1970-01-01 01:00:00.000000000 +0100
+++ libwnck.new/libwnck/tsol-pics.h	2008-08-06 23:43:40.110678000 +0100
@@ -0,0 +1,43 @@
+/* GdkPixbuf RGBA C-Source image dump */
+ 
+#ifdef __SUNPRO_C
+#pragma align 4 (highlight_stripe_pb)
+#endif
+#ifdef __GNUC__
+static const guint8 highlight_stripe_pb[] __attribute__ ((__aligned__ (4))) =
+#else
+static const guint8 highlight_stripe_pb[] =
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (704) */
+  "\0\0\2\330"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (176) */
+  "\0\0\0\260"
+  /* width (44) */
+  "\0\0\0,"
+  /* height (4) */
+  "\0\0\0\4"
+  /* pixel_data: */
+  "\0\0\0\0^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\365^^^\336^^^\303^^^\246^^^\207^^^[^"
+  "^^3^^^\26^^^\5^^^\2^^^\360^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\365^^^\336^^^\303"
+  "^^^\246^^^\207^^^[^^^3^^^\26^^^\5^^^\2^^^\360^^^\377^^^\377^^^\377^^"
+  "^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\365^^^\336^^^\303^^^\246^^^\207^^^[^^^3^^^\26^^^\5^^^\2\0\0\0\0^"
+  "^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377^^^\377"
+  "^^^\377^^^\377^^^\377^^^\365^^^\336^^^\303^^^\246^^^\207^^^[^^^3^^^\26"
+  "^^^\5^^^\2"};
+
diff -urN libwnck.orig/libwnck/window.c libwnck.new/libwnck/window.c
--- libwnck.orig/libwnck/window.c	2008-08-06 23:43:13.689319000 +0100
+++ libwnck.new/libwnck/window.c	2008-08-06 23:43:40.130350000 +0100
@@ -47,6 +47,13 @@
  * referenced or unreferenced.
  */
 
+#ifdef HAVE_XTSOL
+#include <strings.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <wnck-tsol.h>
+#endif
+
 #define FALLBACK_NAME _("Untitled window")
 #define ALL_WORKSPACES (0xFFFFFFFF)
 
@@ -83,6 +90,12 @@
   char *icon_name;
   char *session_id;
   char *session_id_utf8;
+#ifdef HAVE_XTSOL
+  char *label;
+  GdkColor *label_color;
+  char *label_color_str;
+  char *role;
+#endif
   int pid;
   int workspace;
   gint sort_order;
@@ -100,6 +113,9 @@
   int y;
   int width;
   int height;
+#ifdef HAVE_XTSOL
+  int is_trusted;
+#endif
 
   int left_frame;
   int right_frame;
@@ -161,6 +177,9 @@
 
   guint need_emit_name_changed : 1;
   guint need_emit_icon_changed : 1;
+#ifdef HAVE_XTSOL
+  guint need_update_label : 1;
+#endif
 };
 
 G_DEFINE_TYPE (WnckWindow, wnck_window, G_TYPE_OBJECT);
@@ -223,6 +242,9 @@
   window->priv->group_leader = None;
   window->priv->transient_for = None;
   window->priv->icon_geometry.width = -1; /* invalid cached value */
+#ifdef HAVE_XTSOL
+  window->priv->is_trusted = -1;
+#endif
   window->priv->name = NULL;
   window->priv->icon_name = NULL;
   window->priv->session_id = NULL;
@@ -446,6 +468,12 @@
   _wnck_icon_cache_free (window->priv->icon_cache);
   window->priv->icon_cache = NULL;
 
+#ifdef HAVE_XTSOL
+  g_free (window->priv->label);
+  g_free (window->priv->label_color);
+  g_free (window->priv->role);
+#endif
+
   g_free (window->priv->startup_id);
   window->priv->startup_id = NULL;
   g_free (window->priv->res_class);
@@ -559,11 +587,40 @@
   window->priv->need_update_frame_extents = TRUE;
   window->priv->need_emit_name_changed = FALSE;
   window->priv->need_emit_icon_changed = FALSE;
+#ifdef HAVE_XTSOL
+  window->priv->need_update_label = TRUE;
+#endif
   force_update_now (window);
 
   return window;
 }
 
+#ifdef HAVE_XTSOL
+/**
+ * wnck_window_is_trusted:
+ * @window: a #WnckWindow
+ *
+ * Trusted here means that the application running in the window is
+ * in the trusted path.
+ *
+ * Return value: %TRUE if the window is trusted.
+ **/
+gboolean
+wnck_window_is_trusted                (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+  if (!_wnck_check_xtsol_extension()) {
+      g_warning ("wnck_window_is_trusted() was called but the X server does not support the SUN_TSOL extension");
+      return 0;
+  }
+  if (!_wnck_use_trusted_extensions()) {
+      g_warning ("wnck_window_is_trusted(): Can not initialise the trusted extensions libraries. Check your installation");
+      return 0;
+  }
+  return window->priv->is_trusted;
+}
+#endif
+
 void
 _wnck_window_destroy (WnckWindow *window)
 {
@@ -711,6 +768,92 @@
     return g_strdup (name);
 }
 
+#ifdef HAVE_XTSOL
+/**
+ * wnck_window_get_label:
+ * @window: a #WnckWindow
+ *
+ * Gets the sensitivity label of the window in it's long string
+ * representation.
+ *
+ * Return value: sensitivity label of the window.
+ * If the window has no sensitivity label set, %NULL is returned.
+ **/
+const char*
+wnck_window_get_label (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+  if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+      return window->priv->label;
+  return NULL;
+}
+/**
+ * wnck_window_get_label_human_readable:
+ * @window: a #WnckWindow
+ *
+ * Gets the sensitivity label of the window and returns it in a
+ * form suitable for presentation in a user visible interface.
+ *
+ * Return value: sensitivity label of the window appropriate for
+ * human presentation.
+ * If the window has no sensitivity label set, %NULL is returned.
+ **/
+char*
+wnck_window_get_label_human_readable (WnckWindow *window)
+{
+  char *human_readable_label;
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+  if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+    {
+      int error;
+      m_label_t *mlabel = NULL;
+
+      if (wnck_window_is_trusted (window))
+       /* SUN_BRANDING TJDS */
+       return g_strdup (_("Trusted Path"));
+
+      if (window->priv->label != NULL &&
+         (error = libtsol_str_to_label (window->priv->label,
+                                &mlabel, MAC_LABEL,
+                                L_NO_CORRECTION, &error)) == 0)
+       {
+         error = libtsol_label_to_str (mlabel,
+                               &human_readable_label,
+                               M_LABEL, DEF_NAMES);
+         return human_readable_label;
+       }
+    }
+  return NULL;
+}
+
+GdkColor *
+wnck_window_get_label_color (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+  if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+      return window->priv->label_color;
+  else
+      return NULL;
+}
+
+const char *
+wnck_window_get_label_color_str (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+  if (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions())
+      return window->priv->label_color_str;
+  else
+      return NULL;
+}
+
+const char *
+wnck_window_get_role (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return window->priv->role;
+}
+#endif
 
 /**
  * wnck_window_get_application:
@@ -1777,9 +1920,44 @@
 wnck_window_move_to_workspace (WnckWindow    *window,
                                WnckWorkspace *space)
 {
+#ifdef HAVE_XTSOL
+  static char *workstationowner = NULL;
+#endif
+
   g_return_if_fail (WNCK_IS_WINDOW (window));
   g_return_if_fail (WNCK_IS_WORKSPACE (space));
 
+#ifdef HAVE_XTSOL
+  if ((_wnck_check_xtsol_extension) && (_wnck_use_trusted_extensions ())) {
+    char *windowrole = NULL;
+    char *workspacerole = wnck_workspace_get_role (space);
+	windowrole = wnck_window_get_role (window);
+    /*
+     * Only windows that are in the Trusted Path
+     * are allowed to be move onto a role workspace
+     * This could be implemented in _wnck_window_change_workspace() but
+     * it's less complicated to do so here.
+     */
+    if (workstationowner == NULL) {
+      uid_t wsuid;
+      struct passwd *pwd;
+      if ((libxtsol_XTSOLgetWorkstationOwner (gdk_x11_get_default_xdisplay (), &wsuid)) < 0) {
+        g_warning ("XTSOLgetWorkstationOwner() failed. Using getuid() instead");
+        pwd = getpwuid (getuid ());
+      } else
+        pwd = getpwuid (wsuid);
+	  workstationowner = g_strdup (pwd->pw_name);
+    }
+
+    /* Don't allow non-trusted path windows into role workspaces unless the window role
+     * matches the workspace role
+     */
+    if ((workspacerole != NULL) && (strcmp (workstationowner, workspacerole)) &&
+      (!wnck_window_is_trusted (window)) && (strcmp (workspacerole, windowrole)))
+      return;
+  }
+#endif
+
   _wnck_change_workspace (WNCK_SCREEN_XSCREEN (window->priv->screen),
 			  window->priv->xwindow,
                           wnck_workspace_get_number (space));
@@ -2387,9 +2565,38 @@
 wnck_window_is_on_workspace (WnckWindow    *window,
                              WnckWorkspace *workspace)
 {
+#ifdef HAVE_XTSOL
+  static char *workstationowner = NULL;
+#endif
+
   g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
   g_return_val_if_fail (WNCK_IS_WORKSPACE (workspace), FALSE);
   
+#ifdef HAVE_XTSOL
+  /*
+   * Non trusted path windows will not be visible on role workspaces
+   * unless the window role matches the workspace role.
+   */
+  if (_wnck_use_trusted_extensions () && _wnck_check_xtsol_extension ()) {
+	char *windowrole = g_strdup (wnck_window_get_role (window));
+    char *workspacerole = wnck_workspace_get_role (workspace);
+
+    if (workstationowner == NULL) {
+      uid_t wsuid;
+      struct passwd *pwd;
+      if ((libxtsol_XTSOLgetWorkstationOwner (gdk_x11_get_default_xdisplay (), &wsuid)) < 0) {
+        g_warning ("XTSOLgetWorkstationOwner() failed. Using getuid() instead");
+        pwd = getpwuid (getuid ());
+      } else
+        pwd = getpwuid (wsuid);
+	  workstationowner = g_strdup (pwd->pw_name);
+    }
+    if ((workspacerole != NULL) && (strcmp (workstationowner, workspacerole)) &&
+      (!wnck_window_is_trusted (window)) && (strcmp (workspacerole, windowrole))) {
+      return FALSE;
+    }
+  }
+#endif
   return wnck_window_is_pinned (window) ||
     wnck_window_get_workspace (window) == workspace;
 }
@@ -2416,8 +2623,12 @@
   g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
   g_return_val_if_fail (WNCK_IS_WORKSPACE (workspace), FALSE);
 
+  /* Being pinned is no guarantee in a trusted desktop */
+  /* TESTME */
+#ifndef HAVE_XTSOL
   if (wnck_window_is_pinned (window) )
     return TRUE;
+#endif
 
   if (wnck_window_get_workspace (window) != workspace)
     return FALSE;
@@ -2792,6 +3003,91 @@
   window->priv->icon_name = new_name;
 }
 
+#ifdef HAVE_XTSOL
+
+static void 
+update_label_color (WnckWindow *window, m_label_t* label)
+{
+  #define DEFAULT_COLOR	"white"
+  int error;
+
+  if (window->priv->label_color)
+    g_free (window->priv->label_color);
+
+  if (window->priv->label_color_str)
+    g_free (window->priv->label_color_str);
+
+  window->priv->label_color = g_new0 (GdkColor, 1);
+  
+  error = libtsol_label_to_str (label, &window->priv->label_color_str, M_COLOR, DEF_NAMES);
+  if (window->priv->label_color_str == NULL)
+    window->priv->label_color_str = g_strdup(DEFAULT_COLOR);
+
+  gdk_color_parse ((const char*)window->priv->label_color_str, window->priv->label_color);
+}
+
+static void
+update_window_role (WnckWindow *window)
+{
+  int error;
+  gulong xid;
+  uid_t uid = -1;
+  struct passwd *pwd;
+
+  if (window->priv->role)
+    g_free (window->priv->role);
+  xid = wnck_window_get_xid (window);
+  error = libxtsol_XTSOLgetResUID (gdk_x11_get_default_xdisplay (),
+    xid, IsWindow, &uid);
+  if ((error < 0) || (uid < 0)) {
+    pwd = getpwuid (getuid);
+    g_warning ("XTSOLgetResUID() failed. Assuming window %d belongs to %s\n", xid, pwd->pw_name);
+  } else
+    pwd = getpwuid (uid);
+  window->priv->role = g_strdup (pwd->pw_name);
+}
+
+/*
+ * Since window sensitivity labels are static, this is a one time
+ * only function for each window.
+ */
+void
+wnck_window_update_label (WnckWindow *window)
+{
+  g_return_if_fail (window->priv->label == NULL);
+
+  if (!window->priv->need_update_label)
+    return;
+  window->priv->need_update_label = FALSE;
+
+  if (!_wnck_use_trusted_extensions())
+    return;
+
+  /* Check for a trusted windowing environment first */
+  if (_wnck_check_xtsol_extension () && _wnck_use_trusted_extensions()) {
+      if (window->priv->label == NULL) {
+          m_label_t label;
+          int error;
+          if (libxtsol_XTSOLgetResLabel(gdk_display, window->priv->xwindow,
+                                          IsWindow, &label)) {
+             error = libtsol_label_to_str (&label, &window->priv->label, M_INTERNAL,
+                                   LONG_NAMES);
+	      /* add label color */
+	     update_label_color (window, &label);
+	     update_window_role (window);
+	     
+          } else {
+             window->priv->label = NULL;
+          }
+      }
+  } else {
+      g_warning("Window labelling needs the SUN_TSOL X server extension");
+      return;
+  }
+ 
+}
+#endif
+
 static void
 update_workspace (WnckWindow *window)
 {
@@ -3149,6 +3445,14 @@
   if (window->priv->need_emit_name_changed)
     emit_name_changed (window);
 
+#ifdef HAVE_XTSOL
+  if (_wnck_check_xtsol_extension () && _wnck_use_trusted_extensions()) {
+      if (window->priv->is_trusted < 0)
+          window->priv->is_trusted = libxtsol_XTSOLIsWindowTrusted (gdk_display, window->priv->xwindow);
+      if (window->priv->label == NULL)
+          wnck_window_update_label (window);
+  }
+#endif
   old_state = COMPRESS_STATE (window);
   old_actions = window->priv->actions;
 
diff -urN libwnck.orig/libwnck/window.c.orig libwnck.new/libwnck/window.c.orig
--- libwnck.orig/libwnck/window.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ libwnck.new/libwnck/window.c.orig	2008-08-06 23:43:15.390501000 +0100
@@ -0,0 +1,3265 @@
+/* window object */
+/* vim: set sw=2 et: */
+
+/*
+ * Copyright (C) 2001 Havoc Pennington
+ * Copyright (C) 2003 Kim Woelders
+ * Copyright (C) 2003 Red Hat, Inc.
+ * Copyright (C) 2006-2007 Vincent Untz
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <config.h>
+
+#include <glib/gi18n-lib.h>
+#include <string.h>
+#include <time.h>
+
+#include "window.h"
+#include "class-group.h"
+#include "util.h"
+#include "xutils.h"
+#include "private.h"
+#include "wnck-enum-types.h"
+#include "wnck-marshal.h"
+
+/**
+ * SECTION:window
+ * @short_description: an object representing a window.
+ * @see_also: #WnckWorkspace, #WnckApplication, #WnckClassGroup
+ * @stability: Unstable
+ *
+ * The #WnckWindow objects are always owned by libwnck and must not be
+ * referenced or unreferenced.
+ */
+
+#define FALLBACK_NAME _("Untitled window")
+#define ALL_WORKSPACES (0xFFFFFFFF)
+
+static GHashTable *window_hash = NULL;
+
+/* Keep 0-7 in sync with the numbers in the WindowState enum. Yeah I'm
+ * a loser.
+ */
+#define COMPRESS_STATE(window)                          \
+  ( ((window)->priv->is_minimized        << 0) |        \
+    ((window)->priv->is_maximized_horz   << 1) |        \
+    ((window)->priv->is_maximized_vert   << 2) |        \
+    ((window)->priv->is_shaded           << 3) |        \
+    ((window)->priv->skip_pager          << 4) |        \
+    ((window)->priv->skip_taskbar        << 5) |        \
+    ((window)->priv->is_sticky           << 6) |        \
+    ((window)->priv->is_hidden           << 7) |        \
+    ((window)->priv->is_fullscreen       << 8) |        \
+    ((window)->priv->demands_attention   << 9) |        \
+    ((window)->priv->is_urgent           << 10)|        \
+    ((window)->priv->is_above            << 11)|        \
+    ((window)->priv->is_below            << 12))
+
+struct _WnckWindowPrivate
+{
+  Window xwindow;
+  WnckScreen *screen;
+  WnckApplication *app;
+  WnckClassGroup *class_group;
+  Window group_leader;
+  Window transient_for;
+  GdkRectangle icon_geometry;
+  char *name;
+  char *icon_name;
+  char *session_id;
+  char *session_id_utf8;
+  int pid;
+  int workspace;
+  gint sort_order;
+
+  WnckWindowType wintype;
+  
+  GdkPixbuf *icon;
+  GdkPixbuf *mini_icon;
+
+  WnckIconCache *icon_cache;
+  
+  WnckWindowActions actions;
+
+  int x;
+  int y;
+  int width;
+  int height;
+
+  int left_frame;
+  int right_frame;
+  int top_frame;
+  int bottom_frame;
+
+  char *startup_id;
+
+  char *res_class;
+  char *res_name;
+  
+  /* true if transient_for points to root window,
+   * not another app window
+   */
+  guint transient_for_root : 1;
+  
+  /* window state */
+  guint is_minimized : 1;
+  guint is_maximized_horz : 1;
+  guint is_maximized_vert : 1;
+  guint is_shaded : 1;
+  guint is_above : 1;
+  guint is_below : 1;
+  guint skip_pager : 1;
+  guint skip_taskbar : 1;
+  guint is_sticky : 1;
+  guint is_hidden : 1;
+  guint is_fullscreen : 1;
+  guint demands_attention : 1;
+  guint is_urgent : 1;
+
+  time_t needs_attention_time;
+
+  /* _NET_WM_STATE_HIDDEN doesn't map directly into an
+   * externally-visible state (it determines the WM_STATE
+   * interpretation)
+   */
+  guint net_wm_state_hidden : 1;  
+  guint wm_state_iconic : 1;
+  
+  /* idle handler for updates */
+  guint update_handler;
+
+  /* if you add flags, be sure to set them
+   * when we create the window so we get an initial update
+   */
+  guint need_update_name : 1;
+  guint need_update_state : 1;
+  guint need_update_wm_state : 1;
+  guint need_update_icon_name : 1;
+  guint need_update_workspace : 1;
+  guint need_update_actions : 1;
+  guint need_update_wintype : 1;
+  guint need_update_transient_for : 1;
+  guint need_update_startup_id : 1;
+  guint need_update_wmclass : 1;
+  guint need_update_wmhints : 1;
+  guint need_update_frame_extents : 1;
+
+  guint need_emit_name_changed : 1;
+  guint need_emit_icon_changed : 1;
+};
+
+G_DEFINE_TYPE (WnckWindow, wnck_window, G_TYPE_OBJECT);
+#define WNCK_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), WNCK_TYPE_WINDOW, WnckWindowPrivate))
+
+enum {
+  NAME_CHANGED,
+  STATE_CHANGED,
+  WORKSPACE_CHANGED,
+  ICON_CHANGED,
+  ACTIONS_CHANGED,
+  GEOMETRY_CHANGED,
+  LAST_SIGNAL
+};
+
+static void wnck_window_init        (WnckWindow      *window);
+static void wnck_window_class_init  (WnckWindowClass *klass);
+static void wnck_window_finalize    (GObject        *object);
+
+static void emit_name_changed      (WnckWindow      *window);
+static void emit_state_changed     (WnckWindow      *window,
+                                    WnckWindowState  changed_mask,
+                                    WnckWindowState  new_state);
+static void emit_workspace_changed (WnckWindow      *window);
+static void emit_icon_changed      (WnckWindow      *window);
+static void emit_actions_changed   (WnckWindow       *window,
+                                    WnckWindowActions changed_mask,
+                                    WnckWindowActions new_actions);
+static void emit_geometry_changed  (WnckWindow      *window);
+
+static void update_name      (WnckWindow *window);
+static void update_state     (WnckWindow *window);
+static void update_wm_state  (WnckWindow *window);
+static void update_icon_name (WnckWindow *window);
+static void update_workspace (WnckWindow *window);
+static void update_actions   (WnckWindow *window);
+static void update_wintype   (WnckWindow *window);
+static void update_transient_for (WnckWindow *window);
+static void update_startup_id (WnckWindow *window);
+static void update_wmclass    (WnckWindow *window);
+static void update_frame_extents (WnckWindow *window);
+static void unqueue_update   (WnckWindow *window);
+static void queue_update     (WnckWindow *window);
+static void force_update_now (WnckWindow *window);
+
+static WnckWindow* find_last_transient_for (GList *windows,
+                                            Window xwindow);
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static void
+wnck_window_init (WnckWindow *window)
+{
+  window->priv = WNCK_WINDOW_GET_PRIVATE (window);
+
+  window->priv->xwindow = None;
+  window->priv->name = NULL;
+  window->priv->app = NULL;
+  window->priv->class_group = NULL;
+  window->priv->group_leader = None;
+  window->priv->transient_for = None;
+  window->priv->icon_geometry.width = -1; /* invalid cached value */
+  window->priv->name = NULL;
+  window->priv->icon_name = NULL;
+  window->priv->session_id = NULL;
+  window->priv->session_id_utf8 = NULL;
+  window->priv->pid = 0;
+  window->priv->workspace = -1;
+  window->priv->sort_order = G_MAXINT;
+
+  /* FIXME: should we have an invalid window type for this? */
+  window->priv->wintype = 0;
+
+  window->priv->icon = NULL;
+  window->priv->mini_icon = NULL;
+
+  window->priv->icon_cache = _wnck_icon_cache_new ();
+
+  window->priv->actions = 0;
+
+  window->priv->x = 0;
+  window->priv->y = 0;
+  window->priv->width = 0;
+  window->priv->height = 0;
+
+  window->priv->left_frame = 0;
+  window->priv->right_frame = 0;
+  window->priv->top_frame = 0;
+  window->priv->bottom_frame = 0;
+
+  window->priv->startup_id = NULL;
+
+  window->priv->res_class = NULL;
+  window->priv->res_name = NULL;
+
+  window->priv->transient_for_root = FALSE;
+
+  window->priv->is_minimized = FALSE;
+  window->priv->is_maximized_horz = FALSE;
+  window->priv->is_maximized_vert = FALSE;
+  window->priv->is_shaded = FALSE;
+  window->priv->is_above = FALSE;
+  window->priv->is_below = FALSE;
+  window->priv->skip_pager = FALSE;
+  window->priv->skip_taskbar = FALSE;
+  window->priv->is_sticky = FALSE;
+  window->priv->is_hidden = FALSE;
+  window->priv->is_fullscreen = FALSE;
+  window->priv->demands_attention = FALSE;
+  window->priv->is_urgent = FALSE;
+
+  window->priv->needs_attention_time = 0;
+
+  window->priv->net_wm_state_hidden = FALSE;
+  window->priv->wm_state_iconic = FALSE;
+
+  window->priv->update_handler = 0;
+
+  window->priv->need_update_name = FALSE;
+  window->priv->need_update_state = FALSE;
+  window->priv->need_update_wm_state = FALSE;
+  window->priv->need_update_icon_name = FALSE;
+  window->priv->need_update_workspace = FALSE;
+  window->priv->need_update_actions = FALSE;
+  window->priv->need_update_wintype = FALSE;
+  window->priv->need_update_transient_for = FALSE;
+  window->priv->need_update_startup_id = FALSE;
+  window->priv->need_update_wmclass = FALSE;
+  window->priv->need_update_wmhints = FALSE;
+  window->priv->need_update_frame_extents = FALSE;
+
+  window->priv->need_emit_name_changed = FALSE;
+  window->priv->need_emit_icon_changed = FALSE;
+}
+
+static void
+wnck_window_class_init (WnckWindowClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (WnckWindowPrivate));
+
+  object_class->finalize = wnck_window_finalize;
+
+  /**
+   * WnckWindow::name-changed:
+   * @window: the #WnckWindow which emitted the signal.
+   *
+   * Emitted when the name of @window changes.
+   */
+  signals[NAME_CHANGED] =
+    g_signal_new ("name_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWindowClass, name_changed),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
+  /**
+   * WnckWindow::state-changed:
+   * @window: the #WnckWindow which emitted the signal.
+   * @changed_mask: the bitmask containing bits set for all states of @window
+   * that have changed. 
+   * @new_state: the new state of @window.
+   *
+   * Emitted when the state of @window changes. This can happen when @window is
+   * (un)minimized, (un)maximized, (un)sticked, (un)shaded, (un)made above,
+   * (un)made below, (un)set fullscreen, when it needs attention, etc. See
+   * #WnckWindowState for the complete list of states that might have changed.
+   */
+  signals[STATE_CHANGED] =
+    g_signal_new ("state_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWindowClass, state_changed),
+                  NULL, NULL,
+                  _wnck_marshal_VOID__FLAGS_FLAGS,
+                  G_TYPE_NONE, 2,
+                  WNCK_TYPE_WINDOW_STATE, WNCK_TYPE_WINDOW_STATE);
+
+  /**
+   * WnckWindow::workspace-changed:
+   * @window: the #WnckWindow which emitted the signal.
+   *
+   * Emitted when the current workspace of @window changes, or if @window has
+   * been pinned or unpinned.
+   */
+  signals[WORKSPACE_CHANGED] =
+    g_signal_new ("workspace_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWindowClass, workspace_changed),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
+  /**
+   * WnckWindow::icon-changed:
+   * @window: the #WnckWindow which emitted the signal.
+   *
+   * Emitted when the icon of @window changes.
+   */
+  signals[ICON_CHANGED] =
+    g_signal_new ("icon_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWindowClass, icon_changed),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+
+  /**
+   * WnckWindow::actions-changed:
+   * @window: the #WnckWindow which emitted the signal.
+   * @changed_mask: the bitmask containing bits set for all actions
+   * availabilities for @window that have changed. 
+   * @new_state: the new actions availabilities for @window.
+   *
+   * Emitted when the actions availabilities for @window change.
+   */
+  signals[ACTIONS_CHANGED] =
+    g_signal_new ("actions_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWindowClass, actions_changed),
+                  NULL, NULL,
+                  _wnck_marshal_VOID__FLAGS_FLAGS,
+                  G_TYPE_NONE, 2,
+                  WNCK_TYPE_WINDOW_ACTIONS,
+                  WNCK_TYPE_WINDOW_ACTIONS);
+
+  /**
+   * WnckWindow::geometry-changed:
+   * @window: the #WnckWindow which emitted the signal.
+   *
+   * Emitted when the geometry of @window changes.
+   */
+  signals[GEOMETRY_CHANGED] =
+    g_signal_new ("geometry_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWindowClass, geometry_changed),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);  
+}
+
+static void
+wnck_window_finalize (GObject *object)
+{
+  WnckWindow *window;
+
+  window = WNCK_WINDOW (object);
+
+  unqueue_update (window);
+
+  if (window->priv->app)
+    g_object_unref (G_OBJECT (window->priv->app));
+  window->priv->app = NULL;
+
+  if (window->priv->class_group)
+    g_object_unref (G_OBJECT (window->priv->class_group));
+  window->priv->class_group = NULL;
+
+  g_free (window->priv->name);
+  window->priv->name = NULL;
+  g_free (window->priv->icon_name);
+  window->priv->icon_name = NULL;
+  g_free (window->priv->session_id);
+  window->priv->session_id = NULL;
+  g_free (window->priv->session_id_utf8);
+  window->priv->session_id_utf8 = NULL;
+
+  if (window->priv->icon)
+    g_object_unref (G_OBJECT (window->priv->icon));
+  window->priv->icon = NULL;
+
+  if (window->priv->mini_icon)
+    g_object_unref (G_OBJECT (window->priv->mini_icon));
+  window->priv->mini_icon = NULL;
+  
+  _wnck_icon_cache_free (window->priv->icon_cache);
+  window->priv->icon_cache = NULL;
+
+  g_free (window->priv->startup_id);
+  window->priv->startup_id = NULL;
+  g_free (window->priv->res_class);
+  window->priv->res_class = NULL;
+  g_free (window->priv->res_name);
+  window->priv->res_name = NULL;
+
+  G_OBJECT_CLASS (wnck_window_parent_class)->finalize (object);
+}
+
+/**
+ * wnck_window_get:
+ * @xwindow: an X window ID.
+ *
+ * Gets a preexisting #WnckWindow for the X window @xwindow. This will not
+ * create a #WnckWindow if none exists. The function is robust against bogus
+ * window IDs.
+ *
+ * Return value: the #WnckWindow for @xwindow. The returned #WnckWindow is
+ * owned by libwnck and must not be referenced or unreferenced.
+ **/
+WnckWindow*
+wnck_window_get (gulong xwindow)
+{
+  if (window_hash == NULL)
+    return NULL;
+  else
+    return g_hash_table_lookup (window_hash, &xwindow);
+}
+
+/**
+ * wnck_window_get_screen:
+ * @window: a #WnckWindow.
+ *
+ * Gets the #WnckScreen @window is on.
+ *
+ * Return value: the #WnckScreen @window is on. The returned #WnckScreen is
+ * owned by libwnck and must not be referenced or unreferenced.
+ **/
+WnckScreen*
+wnck_window_get_screen (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return window->priv->screen;
+}
+
+WnckWindow*
+_wnck_window_create (Window      xwindow,
+                     WnckScreen *screen,
+                     gint        sort_order)
+{
+  WnckWindow *window;
+
+  if (window_hash == NULL)
+    window_hash = g_hash_table_new (_wnck_xid_hash, _wnck_xid_equal);
+
+  g_return_val_if_fail (g_hash_table_lookup (window_hash, &xwindow) == NULL,
+                        NULL);
+
+  window = g_object_new (WNCK_TYPE_WINDOW, NULL);
+  window->priv->xwindow = xwindow;
+  window->priv->screen = screen;
+
+  g_hash_table_insert (window_hash, &window->priv->xwindow, window);
+
+  /* Hash now owns one ref, caller gets none */
+
+  /* Note that xwindow may correspond to a WnckApplication's xwindow,
+   * that's why we select the union of the mask we want for Application
+   * and the one we want for window
+   */
+  _wnck_select_input (window->priv->xwindow,
+                      WNCK_APP_WINDOW_EVENT_MASK);
+
+  /* Default the group leader to the window itself; it is set in
+   * update_wmhints() if a different group leader is specified.
+   */
+  window->priv->group_leader = window->priv->xwindow;
+
+  window->priv->session_id =
+    _wnck_get_session_id (window->priv->xwindow);
+
+  window->priv->pid =
+    _wnck_get_pid (window->priv->xwindow);
+
+  window->priv->x = 0;
+  window->priv->y = 0;
+  window->priv->width = 0;
+  window->priv->height = 0;
+  _wnck_get_window_geometry (WNCK_SCREEN_XSCREEN (window->priv->screen),
+			     xwindow,
+                             &window->priv->x,
+                             &window->priv->y,
+                             &window->priv->width,
+                             &window->priv->height);
+
+  window->priv->sort_order = sort_order;
+  
+  window->priv->need_update_name = TRUE;
+  window->priv->need_update_state = TRUE;
+  window->priv->need_update_icon_name = TRUE;
+  window->priv->need_update_wm_state = TRUE;
+  window->priv->need_update_workspace = TRUE;
+  window->priv->need_update_actions = TRUE;
+  window->priv->need_update_wintype = TRUE;
+  window->priv->need_update_transient_for = TRUE;
+  window->priv->need_update_startup_id = TRUE;
+  window->priv->need_update_wmclass = TRUE;
+  window->priv->need_update_wmhints = TRUE;
+  window->priv->need_update_frame_extents = TRUE;
+  window->priv->need_emit_name_changed = FALSE;
+  window->priv->need_emit_icon_changed = FALSE;
+  force_update_now (window);
+
+  return window;
+}
+
+void
+_wnck_window_destroy (WnckWindow *window)
+{
+  g_return_if_fail (wnck_window_get (window->priv->xwindow) == window);
+
+  g_hash_table_remove (window_hash, &window->priv->xwindow);
+
+  g_return_if_fail (wnck_window_get (window->priv->xwindow) == NULL);
+
+  window->priv->xwindow = None;
+
+  /* remove hash's ref on the window */
+  g_object_unref (G_OBJECT (window));
+}
+
+/**
+ * wnck_window_has_name:
+ * @window: a #WnckWindow.
+ *
+ * Checks whether or not @window has a name. wnck_window_get_name()
+ * will always return some value, even if @window has no name set;
+ * wnck_window_has_name() can be used to tell if that name is
+ * real or not.
+ *
+ * For icons titles, use wnck_window_has_icon_name() instead.
+ *
+ * Return value: %TRUE if wnck_window_get_name() returns @window<!-- -->'s
+ * name, %FALSE if it returns a fallback name.
+ *
+ * Since: 2.16
+ **/
+gboolean
+wnck_window_has_name (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->name != NULL;
+}
+
+/**
+ * wnck_window_get_name:
+ * @window: a #WnckWindow.
+ *
+ * Gets the name of @window, as it should be displayed in a pager
+ * or tasklist. Always returns some value, even if @window has no name
+ * set; use wnck_window_has_name() if you need to know whether the returned
+ * name is "real" or not.
+ *
+ * For icons titles, use wnck_window_get_icon_name() instead.
+ *
+ * Return value: the name of @window, or a fallback name if no name is
+ * available.
+ **/
+const char*
+wnck_window_get_name (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  if (window->priv->name)
+    return window->priv->name;
+  else
+    return FALLBACK_NAME;
+}
+
+/**
+ * wnck_window_has_icon_name:
+ * @window: a #WnckWindow
+ *
+ * Checks whether or not @window has an icon name.
+ * wnck_window_get_icon_name() will always return some value, even if
+ * @window has no icon name set; wnck_window_has_icon_name() can
+ * be used to tell if that icon name is real or not.
+ *
+ * (Note that if wnck_window_has_icon_name() returns %FALSE, but
+ * wnck_window_has_name() returns %TRUE, then the name returned by
+ * wnck_window_get_icon_name() is @window<!-- -->'s name. Only when both
+ * methods return %FALSE does wnck_window_get_icon_name() return a
+ * generic fallback name.)
+ *
+ * Return value: %TRUE if wnck_window_get_icon_name() returns
+ * @window<!-- -->'s icon name, %FALSE if it returns a fallback name.
+ *
+ * Since: 2.16
+ **/
+gboolean
+wnck_window_has_icon_name (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->icon_name != NULL;
+}
+
+/**
+ * wnck_window_get_icon_name:
+ * @window: a #WnckWindow
+ *
+ * Gets the icon name of @window, as it should be displayed for an icon
+ * (minimized state). Always returns some value, even if @window has no icon
+ * name set; use wnck_window_has_icon_name() if you need to know whether the
+ * returned icon name is "real" or not.
+ *
+ * Contrast with wnck_window_get_name(), which returns @window<!-- -->'s
+ * title, not its icon title.
+ *
+ * Return value: the icon name of @window, or a fallback icon name if no icon
+ * name is available.
+ **/
+const char*
+wnck_window_get_icon_name (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  if (window->priv->icon_name)
+    return window->priv->icon_name;
+  else if (window->priv->name)
+    return window->priv->name;
+  else
+    return FALLBACK_NAME;
+}
+
+char *
+_wnck_window_get_name_for_display (WnckWindow *window,
+                                   gboolean    use_icon_name,
+                                   gboolean    use_state_decorations)
+{
+  const char *name;
+
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+  
+  if (use_icon_name && wnck_window_has_icon_name (window))
+    name = wnck_window_get_icon_name (window);
+  else 
+    name = wnck_window_get_name (window);
+  
+  if (use_state_decorations)
+    {
+      if (window->priv->is_shaded)
+        return g_strdup_printf ("=%s=", name);
+      else if (window->priv->is_minimized)
+        return g_strdup_printf ("[%s]", name);
+      else
+        return g_strdup (name);
+    }
+  else
+    return g_strdup (name);
+}
+
+
+/**
+ * wnck_window_get_application:
+ * @window: a #WnckWindow.
+ *
+ * Gets the #WnckApplication to which @window belongs.
+ *
+ * Return value: the #WnckApplication to which @window belongs. The returned
+ * #WnckApplication is owned by libwnck and must not be referenced or
+ * unreferenced.
+ **/
+WnckApplication*
+wnck_window_get_application  (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return window->priv->app;
+}
+
+/**
+ * wnck_window_get_transient:
+ * @window: a #WnckWindow.
+ *
+ * Gets the #WnckWindow for which @window is transient.
+ *
+ * Return value: the #WnckWindow for which @window is transient, or %NULL if
+ * @window is not transient for any #WnckWindow.
+ *
+ * Since: 2.12
+ **/
+WnckWindow*
+wnck_window_get_transient (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return wnck_window_get (window->priv->transient_for);
+}
+
+/**
+ * wnck_window_get_group_leader:
+ * @window: a #WnckWindow.
+ *
+ * Gets the group leader of the group of windows to which @window belongs.
+ *
+ * Return value: the group leader of the group of windows to which @window
+ * belongs, or the X window ID of @window if @window does not belong to any
+ * group.
+ **/
+gulong
+wnck_window_get_group_leader (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), None);
+
+  return window->priv->group_leader;
+}
+
+/**
+ * wnck_window_get_xid:
+ * @window: a #WnckWindow.
+ *
+ * Gets the X window ID of @window.
+ *
+ * Return value: the X window ID of @window.
+ **/
+gulong
+wnck_window_get_xid (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), None);
+
+  return window->priv->xwindow;
+}
+
+/**
+ * wnck_window_get_class_group:
+ * @window: a #WnckWindow.
+ *
+ * Gets the #WnckClassGroup to which @window belongs.
+ *
+ * Return value: the #WnckClassGroup to which @window belongs. The returned
+ * #WnckClassGroup is owned by libwnck and must not be referenced or
+ * unreferenced.
+ *
+ * Since: 2.2
+ **/
+WnckClassGroup *
+wnck_window_get_class_group (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return window->priv->class_group;
+}
+
+/**
+ * wnck_window_get_session_id:
+ * @window: a #WnckWindow.
+ *
+ * Gets the session ID for @window in Latin-1 encoding.
+ * NOTE: this is invalid UTF-8. You can't display this
+ * string in a GTK+ widget without converting to UTF-8.
+ * See wnck_window_get_session_id_utf8().
+ *
+ * Return value: the session ID for @window in Latin-1, or %NULL if @window has
+ * no session ID.
+ **/
+const char*
+wnck_window_get_session_id (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return window->priv->session_id;
+}
+
+/**
+ * wnck_window_get_session_id_utf8:
+ * @window: a #WnckWindow.
+ *
+ * Gets the session ID for @window in UTF-8 encoding.
+ * The session ID should be in Latin-1 encoding, so the conversion should work,
+ * but a broken client could set a session ID that might not be convertable to
+ * UTF-8.
+ *
+ * Return value: the session ID for @window in UTF-8, or %NULL if @window has
+ * no session ID.
+ **/
+const char*
+wnck_window_get_session_id_utf8 (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  if (window->priv->session_id_utf8 == NULL &&
+      window->priv->session_id != NULL)
+    {
+      GString *str;
+      char *p;
+
+      str = g_string_new ("");
+
+      p = window->priv->session_id;
+      while (*p)
+        {
+          g_string_append_unichar (str, g_utf8_get_char (p));
+          p = g_utf8_next_char (p);
+        }
+
+      window->priv->session_id_utf8 = g_string_free (str, FALSE);
+    }
+
+  return window->priv->session_id_utf8;
+}
+
+/**
+ * wnck_window_get_pid:
+ * @window: a #WnckWindow.
+ *
+ * Gets the process ID of @window.
+ *
+ * Return value: the process ID of @window, or 0 if none is available.
+ **/
+int
+wnck_window_get_pid (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), 0);
+
+  return window->priv->pid;
+}
+
+/**
+ * wnck_window_get_sort_order:
+ * @window: a #WnckWindow.
+ *
+ * Gets the sort order of @window, used for ordering of @window in
+ * #WnckSelector and #WnckTasklist. The sort order is an internal state in
+ * libwnck. The initial value is defined when the window is created.
+ *
+ * Return value: the sort order of @window, or G_MAXINT if none is available.
+ *
+ * Since: 2.10
+ **/
+gint
+wnck_window_get_sort_order (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), G_MAXINT);
+
+  return window->priv->sort_order;
+}
+
+/**
+ * wnck_window_set_sort_order:
+ * @window: a #WnckWindow.
+ * @order: new sort order for @window.
+ *
+ * Sets the sort order of @window. The sort order is used for ordering of
+ * @window in #WnckSelector and #WnckTasklist.
+ *
+ * Since: 2.20
+ **/
+void        wnck_window_set_sort_order        (WnckWindow *window, 
+					       gint order)
+{ 
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+  
+  window->priv->sort_order = order;
+  return;
+}
+
+/**
+ * wnck_window_get_window_type:
+ * @window: a #WnckWindow.
+ * 
+ * Gets the semantic type of @window.
+ * 
+ * Return value: the semantic type of @window.
+ **/
+WnckWindowType
+wnck_window_get_window_type (WnckWindow *window)
+{
+  /* FIXME: should we have an invalid window type for this? */
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), 0);
+  
+  return window->priv->wintype;
+}
+
+/**
+ * wnck_window_set_window_type:
+ * @window: a #WnckWindow.
+ * @wintype: a semantic type.
+ * 
+ * Sets the semantic type of @window to @wintype.
+ *
+ * Since: 2.12
+ **/
+void
+wnck_window_set_window_type (WnckWindow *window, WnckWindowType wintype)
+{
+  Atom atom;
+
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  switch (wintype) {
+  case WNCK_WINDOW_NORMAL:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_NORMAL");
+    break;
+  case WNCK_WINDOW_DESKTOP:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_DESKTOP");
+    break;
+  case WNCK_WINDOW_DOCK:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_DOCK");
+    break;
+  case WNCK_WINDOW_DIALOG:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_DIALOG");
+    break;
+  case WNCK_WINDOW_TOOLBAR:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_TOOLBAR");
+    break;
+  case WNCK_WINDOW_MENU:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_MENU");
+    break;
+  case WNCK_WINDOW_UTILITY:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_UTILITY");
+    break;
+  case WNCK_WINDOW_SPLASHSCREEN:
+    atom = _wnck_atom_get ("_NET_WM_WINDOW_TYPE_SPLASHSCREEN");
+    break;
+  default:
+    return;
+  }
+  _wnck_error_trap_push ();
+
+  XChangeProperty (gdk_display,
+                   window->priv->xwindow, 
+                   _wnck_atom_get ("_NET_WM_WINDOW_TYPE"),
+		   XA_ATOM, 32, PropModeReplace,
+		   (guchar *)&atom, 1);
+
+  _wnck_error_trap_pop ();
+}
+
+/**
+ * wnck_window_is_minimized:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is minimized. Minimization state may change anytime
+ * a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window is minimized, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_minimized (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_minimized;
+}
+
+/**
+ * wnck_window_needs_attention:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window needs attention. This state may change anytime
+ * a #WnckWindow::state-changed signal gets emitted.
+ *
+ * This state depends on flags such as the demands_attention and is_urgent
+ * hints.
+ *
+ * Return value: %TRUE if @window needs attention, %FALSE otherwise.
+ *
+ * Since: 2.12
+ **/
+gboolean
+wnck_window_needs_attention (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->demands_attention || window->priv->is_urgent;
+}
+
+time_t
+_wnck_window_get_needs_attention_time (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), 0);
+
+  return window->priv->needs_attention_time;
+}
+
+/* Return whether the transient of @window needs attention */
+static WnckWindow *
+transient_needs_attention (WnckWindow *window)
+{
+  GList *windows;
+  WnckWindow *transient;
+  
+  if (!WNCK_IS_WINDOW (window))
+    return NULL;
+
+  windows = wnck_screen_get_windows_stacked (window->priv->screen);
+
+  transient = window;
+  while ((transient = find_last_transient_for (windows, transient->priv->xwindow)))
+    {
+      /* catch transient cycles */
+      if (transient == window)
+        return NULL;
+
+      if (wnck_window_needs_attention (transient))
+        return transient;
+    }
+
+  return FALSE;
+}
+
+time_t
+_wnck_window_or_transient_get_needs_attention_time (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), 0);
+
+  if (_wnck_window_get_needs_attention_time (window) == 0)
+    {
+      WnckWindow *transient;
+
+      transient = transient_needs_attention (window);
+      if (transient)
+        return _wnck_window_get_needs_attention_time (transient);
+      else
+        return 0;
+    }
+  else
+    return _wnck_window_get_needs_attention_time (window);
+}
+
+/**
+ * wnck_window_or_transient_needs_attention:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window or one of its transients needs attention. This state
+ * may change anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window or one of its transients needs attention,
+ * %FALSE otherwise.
+ *
+ * Since: 2.12
+ **/
+gboolean
+wnck_window_or_transient_needs_attention (WnckWindow *window)
+{
+  return wnck_window_needs_attention (window) || 
+         transient_needs_attention (window) != NULL;
+}
+
+/**
+ * wnck_window_is_maximized_horizontally:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is maximized horizontally. Horizontal maximization
+ * state may change anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window is maximized horizontally, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_maximized_horizontally (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_maximized_horz;
+}
+
+/**
+ * wnck_window_is_maximized_vertically:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is maximized vertically. vertiVal maximization
+ * state may change anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window is maximized vertically, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_maximized_vertically   (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_maximized_vert;
+}
+
+const char*
+_wnck_window_get_startup_id (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+  
+  if (window->priv->startup_id == NULL &&
+      window->priv->group_leader != None)
+    {
+      WnckApplication *app;
+
+      /* Fall back to group leader property */
+      
+      app = wnck_application_get (window->priv->group_leader);
+      
+      if (app != NULL)
+        return wnck_application_get_startup_id (app);
+      else
+        return NULL;
+    }
+
+  return window->priv->startup_id;
+}
+
+const char*
+_wnck_window_get_resource_class (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return window->priv->res_class;
+}
+
+const char*
+_wnck_window_get_resource_name (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  return window->priv->res_name;
+}
+
+/**
+ * wnck_window_is_maximized:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is maximized. Maximization state may change
+ * anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * As for GDK, "maximized" means both vertically and horizontally. If @window
+ * is maximized in only one direction, then @window is not considered
+ * maximized.
+ *
+ * Return value: %TRUE if @window is maximized in both directions, %FALSE
+ * otherwise.
+ **/
+gboolean
+wnck_window_is_maximized (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return
+    window->priv->is_maximized_horz &&
+    window->priv->is_maximized_vert;
+}
+
+/**
+ * wnck_window_is_shaded:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is shaded. Shade state may change anytime
+ * a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window is shaded, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_shaded                 (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_shaded;
+}
+
+/**
+ * wnck_window_is_above:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is above other windows. This state may change
+ * anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * See wnck_window_make_above() for more details on this state.
+ *
+ * Return value: %TRUE if @window is above other windows, %FALSE otherwise.
+ *
+ * Since: 2.14
+ **/
+gboolean
+wnck_window_is_above                  (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_above;
+}
+
+/**
+ * wnck_window_is_below:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is below other windows. This state may change
+ * anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * See wnck_window_make_below() for more details on this state.
+ *
+ * Return value: %TRUE if @window is below other windows, %FALSE otherwise.
+ *
+ * Since: 2.20
+ **/
+gboolean
+wnck_window_is_below                  (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_below;
+}
+
+/**
+ * wnck_window_is_skip_pager:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is included on pagers. This state may change
+ * anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window is included on pagers, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_skip_pager             (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->skip_pager;
+}
+
+/**
+ * wnck_window_set_skip_pager:
+ * @window: a #WnckWindow.
+ * @skip: whether @window should be included on pagers.
+ *
+ * Asks the window manager to make @window included or not included on pagers.
+ **/
+void
+wnck_window_set_skip_pager (WnckWindow *window,
+                            gboolean skip)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      skip,
+                      _wnck_atom_get ("_NET_WM_STATE_SKIP_PAGER"),
+                      0);
+}
+
+/**
+ * wnck_window_is_skip_tasklist:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is included on tasklists. This state may change
+ * anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window is included on tasklists, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_skip_tasklist          (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->skip_taskbar;
+}
+
+/**
+ * wnck_window_is_fullscreen:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is fullscreen. Fullscreen state may change
+ * anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Return value: %TRUE if @window is fullscreen, %FALSE otherwise.
+ *
+ * Since: 2.8
+ **/
+gboolean
+wnck_window_is_fullscreen                 (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_fullscreen;
+}
+
+/**
+ * wnck_window_set_skip_tasklist:
+ * @window: a #WnckWindow.
+ * @skip: whether @window should be included on tasklists.
+ *
+ * Asks the window manager to make @window included or not included on
+ * tasklists.
+ **/
+void
+wnck_window_set_skip_tasklist (WnckWindow *window,
+                               gboolean skip)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      skip,
+                      _wnck_atom_get ("_NET_WM_STATE_SKIP_TASKBAR"),
+                      0);
+}
+
+/**
+ * wnck_window_set_fullscreen:
+ * @window: a #WnckWindow.
+ * @fullscreen: whether to make @window fullscreen.
+ *
+ * Asks the window manager to set the fullscreen state of @window according to
+ * @fullscreen.
+ *
+ * Since: 2.8
+ **/
+void
+wnck_window_set_fullscreen (WnckWindow *window,
+                               gboolean fullscreen)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      fullscreen,
+                      _wnck_atom_get ("_NET_WM_STATE_FULLSCREEN"),
+                      0);
+}
+
+/**
+ * wnck_window_is_sticky:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is sticky. Sticky state may change
+ * anytime a #WnckWindow::state-changed signal gets emitted.
+ *
+ * Sticky here means "stuck to the glass", i.e. does not scroll with the
+ * viewport. In GDK/GTK+ (e.g. gdk_window_stick()/gtk_window_stick()), sticky
+ * means "stuck to the glass" and <emphasis>also</emphasis> that the window is
+ * on all workspaces. But here it only means the viewport aspect of it.
+ *
+ * Return value: %TRUE if @window is "stuck to the glass", %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_sticky                 (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->is_sticky;
+}
+
+/**
+ * wnck_window_close:
+ * @window: a #WnckWindow.
+ * @timestamp: the X server timestamp of the user interaction event that caused
+ * this call to occur.
+ *
+ * Closes @window.
+ *
+ * This function existed before 2.6, but the @timestamp argument was missing
+ * in earlier versions.
+ * 
+ * Since: 2.6
+ **/
+void
+wnck_window_close (WnckWindow *window,
+		   guint32     timestamp)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_close (WNCK_SCREEN_XSCREEN (window->priv->screen),
+	       window->priv->xwindow, timestamp);
+}
+
+/**
+ * wnck_window_minimize:
+ * @window: a #WnckWindow.
+ *
+ * Minimizes @window.
+ **/
+void
+wnck_window_minimize                (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_iconify (window->priv->xwindow);
+}
+
+/**
+ * wnck_window_unminimize:
+ * @window: a #WnckWindow.
+ * @timestamp: the X server timestamp of the user interaction event that caused
+ * this call to occur.
+ *
+ * Unminimizes @window by activating it or one of its transients. See
+ * wnck_window_activate_transient() for details on how the activation is done.
+ **/
+void
+wnck_window_unminimize              (WnckWindow *window,
+                                     guint32     timestamp)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  wnck_window_activate_transient (window, timestamp);
+}
+
+/**
+ * wnck_window_maximize:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to maximize @window.
+ **/
+void
+wnck_window_maximize                (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      TRUE,
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_VERT"),
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_HORZ"));
+}
+
+/**
+ * wnck_window_unmaximize:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to unmaximize @window.
+ **/
+void
+wnck_window_unmaximize              (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      FALSE,
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_VERT"),
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_HORZ"));
+}
+
+/**
+ * wnck_window_maximize_horizontally:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to maximize horizontally @window.
+ **/
+void
+wnck_window_maximize_horizontally   (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      TRUE,
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_HORZ"),
+                      0);
+}
+
+/**
+ * wnck_window_unmaximize_horizontally:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to unmaximize horizontally @window.
+ **/
+void
+wnck_window_unmaximize_horizontally (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      FALSE,
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_HORZ"),
+                      0);
+}
+
+/**
+ * wnck_window_maximize_vertically:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to maximize vertically @window.
+ **/
+void
+wnck_window_maximize_vertically     (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      TRUE,
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_VERT"),
+                      0);
+}
+
+/**
+ * wnck_window_unmaximize_vertically:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to unmaximize vertically @window.
+ **/
+void
+wnck_window_unmaximize_vertically   (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      FALSE,
+                      _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_VERT"),
+                      0);
+}
+
+/**
+ * wnck_window_shade:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to shade @window.
+ **/
+void
+wnck_window_shade                   (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      TRUE,
+                      _wnck_atom_get ("_NET_WM_STATE_SHADED"),
+                      0);
+}
+
+/**
+ * wnck_window_unshade:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to unshade @window.
+ **/
+void
+wnck_window_unshade                 (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      FALSE,
+                      _wnck_atom_get ("_NET_WM_STATE_SHADED"),
+                      0);
+}
+
+/**
+ * wnck_window_make_above:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to put @window on top of most windows (@window will
+ * not be on top of focused fullscreen windows, of other windows with this
+ * setting and of dock windows).
+ *
+ * Since: 2.14
+ **/
+void
+wnck_window_make_above (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                      window->priv->xwindow,
+                      TRUE,
+                      _wnck_atom_get ("_NET_WM_STATE_ABOVE"),
+                      0);
+}
+
+/**
+ * wnck_window_unmake_above:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to not put @window on top of most windows, and to
+ * put it again in the stack with other windows.
+ *
+ * Since: 2.14
+ **/
+void
+wnck_window_unmake_above (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                      window->priv->xwindow,
+                      FALSE,
+                      _wnck_atom_get ("_NET_WM_STATE_ABOVE"),
+                      0);
+}
+
+/**
+ * wnck_window_make_below:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to put @window below most windows.
+ *
+ * Since: 2.20
+ **/
+void
+wnck_window_make_below (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                      window->priv->xwindow,
+                      TRUE,
+                      _wnck_atom_get ("_NET_WM_STATE_BELOW"),
+                      0);
+}
+
+/**
+ * wnck_window_unmake_below:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to not put @window below most windows, and to
+ * put it again in the stack with other windows.
+ *
+ * Since: 2.20
+ **/
+void
+wnck_window_unmake_below (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                      window->priv->xwindow,
+                      FALSE,
+                      _wnck_atom_get ("_NET_WM_STATE_BELOW"),
+                      0);
+}
+
+/**
+ * wnck_window_stick:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to keep the @window<!-- -->'s position fixed on the
+ * screen, even when the workspace or viewport scrolls.
+ **/
+void
+wnck_window_stick                   (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      TRUE,
+                      _wnck_atom_get ("_NET_WM_STATE_STICKY"),
+                      0);
+}
+
+/**
+ * wnck_window_unstick:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to not have @window<!-- -->'s position fixed on the
+ * screen when the workspace or viewport scrolls.
+ **/
+void
+wnck_window_unstick                 (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_state (WNCK_SCREEN_XSCREEN (window->priv->screen),
+		      window->priv->xwindow,
+                      FALSE,
+                      _wnck_atom_get ("_NET_WM_STATE_STICKY"),
+                      0);
+}
+
+/**
+ * wnck_window_keyboard_move:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to start moving @window via the keyboard.
+ **/
+void
+wnck_window_keyboard_move (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_keyboard_move (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                       window->priv->xwindow);
+}
+
+/**
+ * wnck_window_keyboard_size:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to start resizing @window via the keyboard.
+ **/
+void
+wnck_window_keyboard_size (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_keyboard_size (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                       window->priv->xwindow);
+}
+
+/**
+ * wnck_window_get_workspace:
+ * @window: a #WnckWindow.
+ *
+ * Gets the current workspace @window is on. If the window is pinned (on all
+ * workspaces), or not on any workspaces, %NULL may be returned.
+ *
+ * Return value: the single current workspace @window is on, or %NULL. The
+ * returned #WnckWorkspace is owned by libwnck and must not be referenced or
+ * unreferenced.
+ **/
+WnckWorkspace*
+wnck_window_get_workspace (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  if (window->priv->workspace == ALL_WORKSPACES)
+    return NULL;
+  else
+    return wnck_screen_get_workspace (window->priv->screen, window->priv->workspace);
+}
+
+/**
+ * wnck_window_move_to_workspace:
+ * @window: a #WnckWindow.
+ * @space: a #WnckWorkspace.
+ *
+ * Asks the window manager to move @window to @space.
+ *
+ * FIXME: what happens if @window is pinned?
+ **/
+void
+wnck_window_move_to_workspace (WnckWindow    *window,
+                               WnckWorkspace *space)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+  g_return_if_fail (WNCK_IS_WORKSPACE (space));
+
+  _wnck_change_workspace (WNCK_SCREEN_XSCREEN (window->priv->screen),
+			  window->priv->xwindow,
+                          wnck_workspace_get_number (space));
+}
+
+/**
+ * wnck_window_is_pinned:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is on all workspace. Pinned state may change
+ * anytime a #WnckWindow::workspace-changed signal gets emitted, but not when
+ * a #WnckWindow::state-changed gets emitted.
+ *
+ * Return value: %TRUE if @window is on all workspaces, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_pinned (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window->priv->workspace == ALL_WORKSPACES;
+}
+
+/**
+ * wnck_window_pin:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to put @window on all workspaces.
+ **/
+void
+wnck_window_pin (WnckWindow *window)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_workspace (WNCK_SCREEN_XSCREEN (window->priv->screen),
+			  window->priv->xwindow,
+                          ALL_WORKSPACES);
+}
+
+/**
+ * wnck_window_unpin:
+ * @window: a #WnckWindow.
+ *
+ * Asks the window manager to put @window only in the currently active
+ * workspace, if @window was previously pinned. If @window was not pinned,
+ * does not change @window<!-- -->'s workspace. If the active workspace
+ * is not known for some reason (it should not happen much), sets
+ * @window<!-- -->'s workspace to the first workspace.
+ **/
+void
+wnck_window_unpin (WnckWindow *window)
+{
+  WnckWorkspace *active;
+
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  if (window->priv->workspace != ALL_WORKSPACES)
+    return;
+
+  active = wnck_screen_get_active_workspace (window->priv->screen);
+
+  _wnck_change_workspace (WNCK_SCREEN_XSCREEN (window->priv->screen),
+			  window->priv->xwindow,
+                          active ? wnck_workspace_get_number (active) : 0);
+}
+
+/**
+ * wnck_window_activate:
+ * @window: a #WnckWindow.
+ * @timestamp: the X server timestamp of the user interaction event that caused
+ * this call to occur.
+ *
+ * Asks the window manager to make @window the active window. The
+ * window manager may choose to raise @window along with focusing it, and may
+ * decide to refuse the request (to not steal the focus if there is a more
+ * recent user activity, for example).
+ *
+ * This function existed before 2.10, but the @timestamp argument was missing
+ * in earlier versions.
+ * 
+ * Since: 2.10
+ **/
+void
+wnck_window_activate (WnckWindow *window,
+                      guint32     timestamp)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_activate (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                  window->priv->xwindow,
+                  timestamp);
+}
+
+/**
+ * wnck_window_is_active:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is the active window on its #WnckScreen.
+ *
+ * Return value: %TRUE if @window is the active window on its #WnckScreen,
+ * %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_active (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return window == wnck_screen_get_active_window (window->priv->screen);
+}
+
+/**
+ * wnck_window_is_most_recently_activated:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether @window is the most recently activated window on its
+ * #WnckScreen.
+ *
+ * The most recently activated window is identical to the active
+ * window for click and sloppy focus methods (since a window is always
+ * active in those cases) but differs slightly for mouse focus since
+ * there often is no active window.
+ *
+ * Return value: %TRUE if @window was the most recently activated window on its
+ * #WnckScreen, %FALSE otherwise.
+ *
+ * Since: 2.8
+ **/
+gboolean
+wnck_window_is_most_recently_activated (WnckWindow *window)
+{
+  WnckWindow * current;
+  WnckWindow * previous;
+  WnckWindow * most_recently_activated_window;
+
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  current  = wnck_screen_get_active_window (window->priv->screen);
+  previous = wnck_screen_get_previously_active_window (window->priv->screen);
+
+  if (current)
+    most_recently_activated_window = current;
+  else
+    most_recently_activated_window = previous;
+
+  return (window == most_recently_activated_window);
+}
+
+static WnckWindow*
+find_last_transient_for (GList *windows,
+                         Window xwindow)
+{
+  GList *tmp; 
+  WnckWindow *retval;
+
+  /* find _last_ transient for xwindow in the list */
+  
+  retval = NULL;
+  
+  tmp = windows;
+  while (tmp != NULL)
+    {
+      WnckWindow *w = tmp->data;
+
+      if (w->priv->transient_for == xwindow &&
+	  w->priv->wintype != WNCK_WINDOW_UTILITY)
+        retval = w;
+      
+      tmp = tmp->next;
+    }
+
+  return retval;
+}
+
+/**
+ * wnck_window_activate_transient:
+ * @window: a #WnckWindow.
+ * @timestamp: the X server timestamp of the user interaction event that caused
+ * this call to occur.
+ *
+ * If @window has transients, activates the most likely transient
+ * instead of the window itself. Otherwise activates @window.
+ * 
+ * FIXME the ideal behavior of this function is probably to activate
+ * the most recently active window among @window and its transients.
+ * This is probably best implemented on the window manager side.
+ * 
+ * This function existed before 2.10, but the @timestamp argument was missing
+ * in earlier versions.
+ * 
+ * Since: 2.10
+ **/
+void
+wnck_window_activate_transient (WnckWindow *window,
+                                guint32     timestamp)
+{
+  GList *windows;
+  WnckWindow *transient;
+  WnckWindow *next;
+  
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  windows = wnck_screen_get_windows_stacked (window->priv->screen);
+
+  transient = NULL;
+  next = find_last_transient_for (windows, window->priv->xwindow);
+  
+  while (next != NULL)
+    {
+      if (next == window)
+        {
+          /* catch transient cycles */
+          transient = NULL;
+          break;
+        }
+
+      transient = next;
+      
+      next = find_last_transient_for (windows, transient->priv->xwindow);
+    }
+
+  if (transient != NULL)
+    wnck_window_activate (transient, timestamp);
+  else
+    wnck_window_activate (window, timestamp);
+}
+
+/**
+ * wnck_window_transient_is_most_recently_activated:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether one of the transients of @window is the most
+ * recently activated window. See
+ * wnck_window_is_most_recently_activated() for a more complete
+ * description of what is meant by most recently activated.  This
+ * function is needed because clicking on a #WnckTasklist once will
+ * activate a transient instead of @window itself
+ * (wnck_window_activate_transient), and clicking again should
+ * minimize @window and its transients.  (Not doing this can be
+ * especially annoying in the case of modal dialogs that don't appear
+ * in the #WnckTaslist).
+ * 
+ * Return value: %TRUE if one of the transients of @window is the most recently
+ * activated window, %FALSE otherwise.
+ *
+ * Since: 2.12
+ **/
+gboolean
+wnck_window_transient_is_most_recently_activated (WnckWindow *window)
+{
+  GList *windows;
+  WnckWindow *transient;
+  
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  windows = wnck_screen_get_windows_stacked (window->priv->screen);
+
+  transient = window;
+  while ((transient = find_last_transient_for (windows, transient->priv->xwindow)))
+    {
+      /* catch transient cycles */
+      if (transient == window)
+        return FALSE;
+
+      if (wnck_window_is_most_recently_activated (transient))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static void
+get_icons (WnckWindow *window)
+{
+  GdkPixbuf *icon;
+  GdkPixbuf *mini_icon;
+
+  icon = NULL;
+  mini_icon = NULL;
+  
+  if (_wnck_read_icons (window->priv->xwindow,
+                        window->priv->icon_cache,
+                        &icon,
+                        DEFAULT_ICON_WIDTH, DEFAULT_ICON_HEIGHT,
+                        &mini_icon,
+                        DEFAULT_MINI_ICON_WIDTH,
+                        DEFAULT_MINI_ICON_HEIGHT))
+    {
+      window->priv->need_emit_icon_changed = TRUE;
+
+      if (window->priv->icon)
+        g_object_unref (G_OBJECT (window->priv->icon));
+
+      if (window->priv->mini_icon)
+        g_object_unref (G_OBJECT (window->priv->mini_icon));
+
+      window->priv->icon = icon;
+      window->priv->mini_icon = mini_icon;
+    }
+
+  g_assert ((window->priv->icon && window->priv->mini_icon) ||
+            !(window->priv->icon || window->priv->mini_icon));
+}
+
+/**
+ * wnck_window_get_icon:
+ * @window: a #WnckWindow.
+ * 
+ * Gets the icon to be used for @window. If no icon was found, a fallback
+ * icon is used. wnck_window_get_icon_is_fallback() can be used to tell if the
+ * icon is the fallback icon. 
+ * 
+ * Return value: the icon for @window. The caller should reference the
+ * returned <classname>GdkPixbuf</classname> if it needs to keep the icon
+ * around.
+ **/
+GdkPixbuf*
+wnck_window_get_icon (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+
+  get_icons (window);
+  if (window->priv->need_emit_icon_changed)
+    queue_update (window); /* not done in get_icons since we call that from
+                            * the update
+                            */
+
+  return window->priv->icon;
+}
+
+/**
+ * wnck_window_get_mini_icon:
+ * @window: a #WnckWindow.
+ * 
+ * Gets the mini-icon to be used for @window. If no mini-icon was found, a
+ * fallback mini-icon is used. wnck_window_get_icon_is_fallback() can be used
+ * to tell if the mini-icon is the fallback mini-icon. 
+ * 
+ * Return value: the mini-icon for @window. The caller should reference the
+ * returned <classname>GdkPixbuf</classname> if it needs to keep the icon
+ * around.
+ **/
+GdkPixbuf*
+wnck_window_get_mini_icon (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), NULL);
+  
+  get_icons (window);
+  if (window->priv->need_emit_icon_changed)
+    queue_update (window); /* not done in get_icons since we call that from
+                            * the update
+                            */
+  
+  return window->priv->mini_icon;
+}
+
+/**
+ * wnck_window_get_icon_is_fallback:
+ * @window: a #WnckWindow.
+ *
+ * Gets whether a default fallback icon is used for @window (because none
+ * was set on @window).
+ * 
+ * Return value: %TRUE if the icon for @window is a fallback, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_get_icon_is_fallback (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+
+  return _wnck_icon_cache_get_is_fallback (window->priv->icon_cache);
+}
+
+/**
+ * wnck_window_get_actions:
+ * @window: a #WnckWindow.
+ * 
+ * Gets the actions that can be done for @window.
+ * 
+ * Return value: bitmask of actions that can be done for @window.
+ **/
+WnckWindowActions
+wnck_window_get_actions (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), 0);
+
+  return window->priv->actions;
+}
+
+
+/**
+ * wnck_window_get_state:
+ * @window: a #WnckWindow.
+ * 
+ * Gets the state of @window.
+ * 
+ * Return value: bitmask of active states for @window.
+ **/
+WnckWindowState
+wnck_window_get_state (WnckWindow *window)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), 0);
+
+  return COMPRESS_STATE (window);
+}
+
+/**
+ * wnck_window_get_client_window_geometry:
+ * @window: a #WnckWindow.
+ * @xp: return location for X coordinate in pixels of @window.
+ * @yp: return location for Y coordinate in pixels of @window.
+ * @widthp: return location for width in pixels of @window.
+ * @heightp: return location for height in pixels of @window.
+ *
+ * Gets the size and position of @window, as last received
+ * in a ConfigureNotify event (i.e. this call does not round-trip
+ * to the server, just gets the last size we were notified of).
+ * The X and Y coordinates are relative to the root window.
+ *
+ * The window manager usually adds a frame around windows. If
+ * you need to know the size of @window with the frame, use
+ * wnck_window_get_geometry().
+ *
+ * Since: 2.20
+ **/
+void
+wnck_window_get_client_window_geometry (WnckWindow *window,
+                                        int        *xp,
+					int        *yp,
+					int        *widthp,
+					int        *heightp)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  if (xp)
+    *xp = window->priv->x;
+  if (yp)
+    *yp = window->priv->y;
+  if (widthp)
+    *widthp = window->priv->width;
+  if (heightp)
+    *heightp = window->priv->height;
+}
+
+/**
+ * wnck_window_get_geometry:
+ * @window: a #WnckWindow.
+ * @xp: return location for X coordinate in pixels of @window.
+ * @yp: return location for Y coordinate in pixels of @window.
+ * @widthp: return location for width in pixels of @window.
+ * @heightp: return location for height in pixels of @window.
+ *
+ * Gets the size and position of @window, including decorations. This
+ * function uses the information last received in a ConfigureNotify
+ * event and adjusts it according to the size of the frame that is
+ * added by the window manager (this call does not round-trip to the
+ * server, it just gets the last sizes that were notified). The
+ * X and Y coordinates are relative to the root window.
+ *
+ * If you need to know the actual size of @window ignoring the frame
+ * added by the window manager, use wnck_window_get_client_window_geometry().
+ **/
+void
+wnck_window_get_geometry (WnckWindow *window,
+                          int        *xp,
+                          int        *yp,
+                          int        *widthp,
+                          int        *heightp)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  if (xp)
+    *xp = window->priv->x - window->priv->left_frame;
+  if (yp)
+    *yp = window->priv->y - window->priv->top_frame;
+  if (widthp)
+    *widthp = window->priv->width + window->priv->left_frame + window->priv->right_frame;
+  if (heightp)
+    *heightp = window->priv->height + window->priv->top_frame + window->priv->bottom_frame;
+}
+
+/**
+ * wnck_window_set_geometry:
+ * @window: a #WnckWindow.
+ * @gravity: the gravity point to use as a reference for the new position.
+ * @geometry_mask: a bitmask containing flags for what should be set.
+ * @x: new X coordinate in pixels of @window.
+ * @y: new Y coordinate in pixels of @window.
+ * @width: new width in pixels of @window.
+ * @height: new height in pixels of @window.
+ *
+ * Sets the size and position of @window. The X and Y coordinates should be
+ * relative to the root window.
+ *
+ * Note that the new size and position apply to @window with its frame added
+ * by the window manager. Therefore, using wnck_window_set_geometry() with
+ * the values returned by wnck_window_get_geometry() should be a no-op, while
+ * using wnck_window_set_geometry() with the values returned by
+ * wnck_window_get_client_window_geometry() should reduce the size of @window
+ * and move it.
+ *
+ * Since: 2.16
+ **/
+void
+wnck_window_set_geometry (WnckWindow               *window,
+                          WnckWindowGravity         gravity,
+                          WnckWindowMoveResizeMask  geometry_mask,
+                          int                       x,
+                          int                       y,
+                          int                       width,
+                          int                       height)
+{
+  int gravity_and_flags;
+  int source;
+
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  source = _wnck_get_client_type();
+  gravity_and_flags = gravity;
+  gravity_and_flags |= geometry_mask << 8;
+  gravity_and_flags |= source << 12;
+  
+  x += window->priv->left_frame;
+  y += window->priv->top_frame;
+  width -= window->priv->left_frame + window->priv->right_frame;
+  height -= window->priv->top_frame + window->priv->bottom_frame;
+
+  _wnck_set_window_geometry (WNCK_SCREEN_XSCREEN (window->priv->screen),
+                             window->priv->xwindow,
+                             gravity_and_flags, x, y, width, height);
+}
+
+/**
+ * wnck_window_is_visible_on_workspace:
+ * @window: a #WnckWindow.
+ * @workspace: a #WnckWorkspace.
+ * 
+ * Like wnck_window_is_on_workspace(), but also checks that
+ * the window is in a visible state (i.e. not minimized or shaded).
+ * 
+ * Return value: %TRUE if @window appears on @workspace in normal state, %FALSE
+ * otherwise.
+ **/
+gboolean
+wnck_window_is_visible_on_workspace (WnckWindow    *window,
+                                     WnckWorkspace *workspace)
+{
+  WnckWindowState state;
+
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+  g_return_val_if_fail (WNCK_IS_WORKSPACE (workspace), FALSE);
+  
+  state = wnck_window_get_state (window);
+
+  if (state & WNCK_WINDOW_STATE_HIDDEN)
+    return FALSE; /* not visible */
+
+  return wnck_window_is_on_workspace (window, workspace);
+}
+
+/**
+ * wnck_window_set_icon_geometry:
+ * @window: a #WnckWindow.
+ * @x: X coordinate in pixels.
+ * @y: Y coordinate in pixels.
+ * @width: width in pixels.
+ * @height: height in pixels.
+ *
+ * Sets the icon geometry for @window. A typical use case for this is the
+ * destination of the minimization animation of @window.
+ */
+void
+wnck_window_set_icon_geometry (WnckWindow *window,
+			       int         x,
+			       int         y,
+			       int         width,
+			       int         height)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  if (window->priv->icon_geometry.x == x &&
+      window->priv->icon_geometry.y == y &&
+      window->priv->icon_geometry.width == width &&
+      window->priv->icon_geometry.height == height)
+    return;
+
+  window->priv->icon_geometry.x = x;
+  window->priv->icon_geometry.y = y;
+  window->priv->icon_geometry.width = width;
+  window->priv->icon_geometry.height = height;
+
+  _wnck_set_icon_geometry (window->priv->xwindow,
+                           x, y, width, height);
+}
+
+/**
+ * wnck_window_is_on_workspace:
+ * @window: a #WnckWindow.
+ * @workspace: a #WnckWorkspace.
+ * 
+ * Gets whether @window appears on @workspace.
+ *
+ * Return value: %TRUE if @window appears on @workspace, %FALSE otherwise.
+ **/
+gboolean
+wnck_window_is_on_workspace (WnckWindow    *window,
+                             WnckWorkspace *workspace)
+{
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+  g_return_val_if_fail (WNCK_IS_WORKSPACE (workspace), FALSE);
+  
+  return wnck_window_is_pinned (window) ||
+    wnck_window_get_workspace (window) == workspace;
+}
+
+/**
+ * wnck_window_is_in_viewport:
+ * @window: a #WnckWindow.
+ * @workspace: a #WnckWorkspace.
+ * 
+ * Gets %TRUE if @window appears in the current viewport of @workspace.
+ * 
+ * Return value: %TRUE if @window appears in current viewport of @workspace,
+ * %FALSE otherwise.
+ *
+ * Since: 2.4
+ **/
+gboolean
+wnck_window_is_in_viewport (WnckWindow    *window,
+                            WnckWorkspace *workspace)
+{
+  GdkRectangle window_rect;
+  GdkRectangle viewport_rect;
+  
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), FALSE);
+  g_return_val_if_fail (WNCK_IS_WORKSPACE (workspace), FALSE);
+
+  if (wnck_window_is_pinned (window) )
+    return TRUE;
+
+  if (wnck_window_get_workspace (window) != workspace)
+    return FALSE;
+
+  viewport_rect.x = wnck_workspace_get_viewport_x (workspace);
+  viewport_rect.y = wnck_workspace_get_viewport_y (workspace);
+  viewport_rect.width = wnck_screen_get_width (window->priv->screen);
+  viewport_rect.height = wnck_screen_get_height (window->priv->screen);
+
+  window_rect.x = window->priv->x - window->priv->left_frame + viewport_rect.x;
+  window_rect.y = window->priv->y - window->priv->top_frame + viewport_rect.y;
+  window_rect.width = window->priv->width + window->priv->left_frame + window->priv->right_frame;
+  window_rect.height = window->priv->height + window->priv->top_frame + window->priv->bottom_frame;
+
+  return gdk_rectangle_intersect (&viewport_rect, &window_rect, &window_rect);
+}
+
+void
+_wnck_window_set_application (WnckWindow      *window,
+                              WnckApplication *app)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+  g_return_if_fail (app == NULL || WNCK_IS_APPLICATION (app));
+
+  if (app)
+    g_object_ref (G_OBJECT (app));
+  if (window->priv->app)
+    g_object_unref (G_OBJECT (window->priv->app));
+  window->priv->app = app;
+}
+
+void
+_wnck_window_set_class_group (WnckWindow     *window,
+			      WnckClassGroup *class_group)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+  g_return_if_fail (class_group == NULL || WNCK_IS_CLASS_GROUP (class_group));
+
+  if (class_group)
+    g_object_ref (G_OBJECT (class_group));
+  if (window->priv->class_group)
+    g_object_unref (G_OBJECT (window->priv->class_group));
+  window->priv->class_group = class_group;
+}
+
+void
+_wnck_window_process_property_notify (WnckWindow *window,
+                                      XEvent     *xevent)
+{
+  if (xevent->xproperty.atom ==
+      _wnck_atom_get ("_NET_WM_STATE"))
+    {
+      window->priv->need_update_state = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+      _wnck_atom_get ("WM_STATE"))
+    {
+      window->priv->need_update_wm_state = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           XA_WM_NAME ||
+           xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_NAME") ||
+           xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_VISIBLE_NAME"))
+    {
+      window->priv->need_update_name = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           XA_WM_ICON_NAME ||
+           xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_ICON_NAME") ||
+           xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_VISIBLE_ICON_NAME"))
+    {
+      window->priv->need_update_icon_name = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_ALLOWED_ACTIONS"))
+    {
+      window->priv->need_update_actions = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_DESKTOP"))
+    {
+      window->priv->need_update_workspace = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_WINDOW_TYPE"))
+    {
+      window->priv->need_update_wintype = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("WM_TRANSIENT_FOR"))
+    {
+      window->priv->need_update_transient_for = TRUE;
+      window->priv->need_update_wintype = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_STARTUP_ID"))
+    {
+      window->priv->need_update_startup_id = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom == XA_WM_CLASS)
+    {
+      window->priv->need_update_wmclass = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_ICON") ||
+           xevent->xproperty.atom ==
+           _wnck_atom_get ("KWM_WIN_ICON"))
+    {
+      _wnck_icon_cache_property_changed (window->priv->icon_cache,
+                                         xevent->xproperty.atom);
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+  	   _wnck_atom_get ("WM_HINTS"))
+    {
+      window->priv->need_update_wmhints = TRUE;
+      queue_update (window);
+    }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_FRAME_EXTENTS"))
+    {
+      window->priv->need_update_frame_extents = TRUE;
+      queue_update (window);
+    }
+}
+
+void
+_wnck_window_process_configure_notify (WnckWindow *window,
+                                       XEvent     *xevent)
+{
+  if (xevent->xconfigure.send_event)
+    {
+      window->priv->x = xevent->xconfigure.x;
+      window->priv->y = xevent->xconfigure.y;
+    }
+  else
+    {
+      _wnck_get_window_position (WNCK_SCREEN_XSCREEN (window->priv->screen),
+				 window->priv->xwindow,
+                                 &window->priv->x,
+                                 &window->priv->y);
+    }
+
+  window->priv->width = xevent->xconfigure.width;
+  window->priv->height = xevent->xconfigure.height;
+
+  emit_geometry_changed (window);
+}
+
+static void
+update_wm_state (WnckWindow *window)
+{
+  int state;
+
+  if (!window->priv->need_update_wm_state)
+    return;
+
+  window->priv->need_update_wm_state = FALSE;
+
+  window->priv->wm_state_iconic = FALSE;
+
+  state = _wnck_get_wm_state (window->priv->xwindow);
+
+  if (state == IconicState)
+    window->priv->wm_state_iconic = TRUE;
+}
+
+static void
+update_state (WnckWindow *window)
+{
+  Atom *atoms;
+  int n_atoms;
+  int i;
+  gboolean reread_net_wm_state;
+
+  reread_net_wm_state = window->priv->need_update_state;
+
+  window->priv->need_update_state = FALSE;
+
+  /* This is a bad hack, we always add the
+   * state based on window type in to the state,
+   * even if no state update is pending (since the
+   * state update just means the _NET_WM_STATE prop
+   * changed
+   */
+  
+  if (reread_net_wm_state)
+    {
+      gboolean demanded_attention;
+
+      demanded_attention = window->priv->demands_attention;
+
+      window->priv->is_maximized_horz = FALSE;
+      window->priv->is_maximized_vert = FALSE;
+      window->priv->is_sticky = FALSE;
+      window->priv->is_shaded = FALSE;
+      window->priv->is_above = FALSE;
+      window->priv->is_below = FALSE;
+      window->priv->skip_taskbar = FALSE;
+      window->priv->skip_pager = FALSE;
+      window->priv->net_wm_state_hidden = FALSE;
+      window->priv->is_fullscreen = FALSE;
+      window->priv->demands_attention = FALSE;
+      
+      atoms = NULL;
+      n_atoms = 0;
+      _wnck_get_atom_list (window->priv->xwindow,
+                           _wnck_atom_get ("_NET_WM_STATE"),
+                           &atoms, &n_atoms);
+
+      i = 0;
+      while (i < n_atoms)
+        {
+          if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_VERT"))
+            window->priv->is_maximized_vert = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_MAXIMIZED_HORZ"))
+            window->priv->is_maximized_horz = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_HIDDEN"))
+            window->priv->net_wm_state_hidden = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_STICKY"))
+            window->priv->is_sticky = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_SHADED"))
+            window->priv->is_shaded = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_ABOVE"))
+            window->priv->is_above = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_BELOW"))
+            window->priv->is_below = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_FULLSCREEN"))
+            window->priv->is_fullscreen = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_SKIP_TASKBAR"))
+            window->priv->skip_taskbar = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_SKIP_PAGER"))
+            window->priv->skip_pager = TRUE;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_STATE_DEMANDS_ATTENTION"))
+            window->priv->demands_attention = TRUE;
+
+          ++i;
+        }
+
+      if (window->priv->demands_attention != demanded_attention)
+        {
+          if (window->priv->demands_attention)
+            time (&window->priv->needs_attention_time);
+          else if (!window->priv->is_urgent)
+            window->priv->needs_attention_time = 0;
+        }
+
+      g_free (atoms);
+    }
+
+  switch (window->priv->wintype)
+    {
+    case WNCK_WINDOW_DESKTOP:
+    case WNCK_WINDOW_DOCK:
+    case WNCK_WINDOW_SPLASHSCREEN:
+      window->priv->skip_taskbar = TRUE;
+      break;
+
+    case WNCK_WINDOW_TOOLBAR:
+    case WNCK_WINDOW_MENU:
+    case WNCK_WINDOW_UTILITY:
+    case WNCK_WINDOW_DIALOG:
+      /* Skip taskbar if the window is transient
+       * for some main application window
+       */
+      if (wnck_window_get_transient (window) != NULL &&
+          !window->priv->transient_for_root)
+        window->priv->skip_taskbar = TRUE;
+      break;
+      
+    case WNCK_WINDOW_NORMAL:
+      break;
+    }
+
+  /* FIXME!!!!!!!!!! What in the world is this buggy duplicate of the code
+   * immediately above this for??!?!?
+   */
+  switch (window->priv->wintype)
+    {
+    case WNCK_WINDOW_DESKTOP:
+    case WNCK_WINDOW_DOCK:
+    case WNCK_WINDOW_TOOLBAR:
+    case WNCK_WINDOW_MENU:
+    case WNCK_WINDOW_SPLASHSCREEN:
+      window->priv->skip_pager = TRUE;
+      break;
+      
+    case WNCK_WINDOW_NORMAL:
+    case WNCK_WINDOW_DIALOG:
+    case WNCK_WINDOW_UTILITY:
+      break;
+    }
+  
+  /* FIXME we need to recompute this if the window manager changes */
+  if (wnck_screen_net_wm_supports (window->priv->screen,
+                                   "_NET_WM_STATE_HIDDEN"))
+    {
+      window->priv->is_hidden = window->priv->net_wm_state_hidden;
+
+      /* FIXME this is really broken; need to bring it up on
+       * wm-spec-list. It results in showing an "Unminimize" menu
+       * item on task list, for shaded windows.
+       */
+      window->priv->is_minimized = window->priv->is_hidden;
+    }
+  else
+    {
+      window->priv->is_minimized = window->priv->wm_state_iconic;
+      
+      window->priv->is_hidden = window->priv->is_minimized || window->priv->is_shaded;
+    }
+}
+
+static gboolean
+nullstr_equal (const char *str1, const char *str2)
+{
+  if (str1 == NULL || str2 == NULL)
+    return str1 == str2;
+  else
+    return !strcmp (str1, str2);
+}
+
+static void
+update_name (WnckWindow *window)
+{
+  char *new_name;
+
+  if (!window->priv->need_update_name)
+    return;
+
+  window->priv->need_update_name = FALSE;
+
+  new_name = _wnck_get_name (window->priv->xwindow);
+
+  if (!nullstr_equal (window->priv->name, new_name))
+    window->priv->need_emit_name_changed = TRUE;
+
+  g_free (window->priv->name);
+  window->priv->name = new_name;
+}
+
+static void
+update_icon_name (WnckWindow *window)
+{
+  char *new_name = NULL;
+
+  if (!window->priv->need_update_icon_name)
+    return;
+
+  window->priv->need_update_icon_name = FALSE;
+
+  new_name = _wnck_get_icon_name (window->priv->xwindow);
+
+  if (!nullstr_equal (window->priv->icon_name, new_name))
+    window->priv->need_emit_name_changed = TRUE;
+
+  g_free (window->priv->icon_name);
+  window->priv->icon_name = new_name;
+}
+
+static void
+update_workspace (WnckWindow *window)
+{
+  int val;
+  int old;
+
+  if (!window->priv->need_update_workspace)
+    return;
+
+  window->priv->need_update_workspace = FALSE;
+
+  old = window->priv->workspace;
+
+  val = ALL_WORKSPACES;
+  _wnck_get_cardinal (window->priv->xwindow,
+                      _wnck_atom_get ("_NET_WM_DESKTOP"),
+                      &val);
+
+  window->priv->workspace = val;
+
+  if (old != window->priv->workspace)
+    emit_workspace_changed (window);
+}
+
+static void
+update_actions (WnckWindow *window)
+{
+  Atom *atoms;
+  int   n_atoms;
+  int   i;
+
+  if (!window->priv->need_update_actions)
+    return;
+
+  window->priv->need_update_actions = FALSE;
+
+  window->priv->actions = 0;
+
+  atoms = NULL;
+  n_atoms = 0;
+  if (!_wnck_get_atom_list (window->priv->xwindow,
+                            _wnck_atom_get ("_NET_WM_ALLOWED_ACTIONS"),
+                            &atoms,
+                            &n_atoms))
+    {
+      window->priv->actions = 
+                WNCK_WINDOW_ACTION_MOVE                    |
+                WNCK_WINDOW_ACTION_RESIZE                  |
+                WNCK_WINDOW_ACTION_SHADE                   |
+                WNCK_WINDOW_ACTION_STICK                   |
+                WNCK_WINDOW_ACTION_MAXIMIZE_HORIZONTALLY   |
+                WNCK_WINDOW_ACTION_MAXIMIZE_VERTICALLY     |
+                WNCK_WINDOW_ACTION_CHANGE_WORKSPACE        |
+                WNCK_WINDOW_ACTION_CLOSE                   |
+                WNCK_WINDOW_ACTION_UNMAXIMIZE_HORIZONTALLY |
+                WNCK_WINDOW_ACTION_UNMAXIMIZE_VERTICALLY   |
+                WNCK_WINDOW_ACTION_UNSHADE                 |
+                WNCK_WINDOW_ACTION_UNSTICK                 |
+                WNCK_WINDOW_ACTION_MINIMIZE                |
+                WNCK_WINDOW_ACTION_UNMINIMIZE              |
+                WNCK_WINDOW_ACTION_MAXIMIZE                |
+                WNCK_WINDOW_ACTION_UNMAXIMIZE              |
+                WNCK_WINDOW_ACTION_FULLSCREEN              |
+                WNCK_WINDOW_ACTION_ABOVE                   |
+                WNCK_WINDOW_ACTION_BELOW;
+      return;
+    }
+
+  i = 0;
+  while (i < n_atoms)
+    {
+      if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_MOVE"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_MOVE;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_RESIZE"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_RESIZE;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_SHADE"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_SHADE |
+                                 WNCK_WINDOW_ACTION_UNSHADE;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_STICK"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_STICK |
+                                 WNCK_WINDOW_ACTION_UNSTICK;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_MINIMIZE"))
+	window->priv->actions |= WNCK_WINDOW_ACTION_MINIMIZE   |
+	                         WNCK_WINDOW_ACTION_UNMINIMIZE;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_MAXIMIZE_HORZ"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_MAXIMIZE_HORIZONTALLY |
+                                 WNCK_WINDOW_ACTION_UNMAXIMIZE_HORIZONTALLY;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_MAXIMIZE_VERT"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_MAXIMIZE_VERTICALLY |
+                                 WNCK_WINDOW_ACTION_UNMAXIMIZE_VERTICALLY;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_CHANGE_DESKTOP"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_CHANGE_WORKSPACE;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_CLOSE"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_CLOSE;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_FULLSCREEN"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_FULLSCREEN;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_ABOVE"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_ABOVE;
+
+      else if (atoms[i] == _wnck_atom_get ("_NET_WM_ACTION_BELOW"))
+        window->priv->actions |= WNCK_WINDOW_ACTION_BELOW;
+
+      else
+        {
+          const char *name = _wnck_atom_name (atoms [i]);
+          g_warning ("Unhandled action type %s", name ? name: "(nil)");
+        }
+
+      i++;
+    }
+
+  g_free (atoms);
+
+  if ((window->priv->actions & WNCK_WINDOW_ACTION_MAXIMIZE_HORIZONTALLY) &&
+      (window->priv->actions & WNCK_WINDOW_ACTION_MAXIMIZE_VERTICALLY))
+    window->priv->actions |=
+        WNCK_WINDOW_ACTION_MAXIMIZE   |
+        WNCK_WINDOW_ACTION_UNMAXIMIZE;
+}
+
+static void
+update_wintype (WnckWindow *window)
+{
+  Atom *atoms;
+  int n_atoms;
+  WnckWindowType type;
+  gboolean found_type;
+  
+  if (!window->priv->need_update_wintype)
+    return;
+
+  window->priv->need_update_wintype = FALSE;
+
+  found_type = FALSE;
+  type = WNCK_WINDOW_NORMAL;
+  
+  atoms = NULL;
+  n_atoms = 0;
+  if (_wnck_get_atom_list (window->priv->xwindow,
+                           _wnck_atom_get ("_NET_WM_WINDOW_TYPE"),
+                           &atoms,
+                           &n_atoms))
+    {
+      int i;
+      
+      i = 0;
+      while (i < n_atoms && !found_type)
+        {
+          /* We break as soon as we find one we recognize,
+           * supposed to prefer those near the front of the list
+           */
+          found_type = TRUE;
+          if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_DESKTOP"))
+            type = WNCK_WINDOW_DESKTOP;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_DOCK"))
+            type = WNCK_WINDOW_DOCK;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_TOOLBAR"))
+            type = WNCK_WINDOW_TOOLBAR;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_MENU"))
+            type = WNCK_WINDOW_MENU;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_DIALOG"))
+            type = WNCK_WINDOW_DIALOG;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_NORMAL"))
+            type = WNCK_WINDOW_NORMAL;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_UTILITY"))
+            type = WNCK_WINDOW_UTILITY;
+          else if (atoms[i] == _wnck_atom_get ("_NET_WM_WINDOW_TYPE_SPLASH"))
+            type = WNCK_WINDOW_SPLASHSCREEN;
+          else
+            found_type = FALSE;
+          
+          ++i;
+        }
+
+      g_free (atoms);
+    }
+
+  if (!found_type)
+    {
+      if (window->priv->transient_for != None)
+        {
+          type = WNCK_WINDOW_DIALOG;
+        }
+      else
+        {
+          type = WNCK_WINDOW_NORMAL;
+        }
+      found_type = TRUE;
+    }
+
+  window->priv->wintype = type;
+}
+
+static void
+update_transient_for (WnckWindow *window)
+{
+  Window parent;
+
+  if (!window->priv->need_update_transient_for)
+    return;
+
+  window->priv->need_update_transient_for = FALSE;
+  
+  parent = None;
+  if (_wnck_get_window (window->priv->xwindow,
+                        _wnck_atom_get ("WM_TRANSIENT_FOR"),
+                        &parent) &&
+      parent != window->priv->xwindow)
+    {
+      window->priv->transient_for = parent;
+
+      if (wnck_screen_get_for_root (window->priv->transient_for) != NULL)
+        window->priv->transient_for_root = TRUE;
+      else
+        window->priv->transient_for_root = FALSE;
+    }
+  else
+    {
+      window->priv->transient_for = None;
+      window->priv->transient_for_root = FALSE;
+    }
+}
+
+static void
+update_startup_id (WnckWindow *window)
+{
+  if (!window->priv->need_update_startup_id)
+    return;
+
+  window->priv->need_update_startup_id = FALSE;
+
+  g_free (window->priv->startup_id);
+  window->priv->startup_id = 
+    _wnck_get_utf8_property (window->priv->xwindow,
+                             _wnck_atom_get ("_NET_STARTUP_ID"));
+}
+
+static void
+update_wmclass (WnckWindow *window)
+{
+  if (!window->priv->need_update_wmclass)
+    return;
+
+  window->priv->need_update_wmclass = FALSE;
+
+  g_free (window->priv->res_class);
+  g_free (window->priv->res_name);
+
+  window->priv->res_class = NULL;
+  window->priv->res_name = NULL;
+
+  _wnck_get_wmclass (window->priv->xwindow,
+                     &window->priv->res_class,
+                     &window->priv->res_name);
+}
+
+static void
+update_wmhints (WnckWindow *window)
+{
+  XWMHints *hints;
+
+  if (!window->priv->need_update_wmhints)
+    return;
+
+  _wnck_error_trap_push ();
+  hints = XGetWMHints (gdk_display, window->priv->xwindow);
+  _wnck_error_trap_pop ();
+
+  if (hints)
+    {
+      if ((hints->flags & IconPixmapHint) ||
+          (hints->flags & IconMaskHint))
+        _wnck_icon_cache_property_changed (window->priv->icon_cache,
+                                           _wnck_atom_get ("WM_HINTS"));
+
+      if (hints->flags & WindowGroupHint)
+          window->priv->group_leader = hints->window_group;
+
+      if (hints->flags & XUrgencyHint)
+        {
+          window->priv->is_urgent = TRUE;
+          time (&window->priv->needs_attention_time);
+        }
+      else
+        {
+          window->priv->is_urgent = FALSE;
+          if (!window->priv->demands_attention)
+            window->priv->needs_attention_time = 0;
+        }
+
+      XFree (hints);
+    }
+
+  window->priv->need_update_wmhints = FALSE;
+}
+
+static void
+update_frame_extents (WnckWindow *window)
+{
+  int left, right, top, bottom;
+
+  if (!window->priv->need_update_frame_extents)
+    return;
+
+  window->priv->need_update_frame_extents = FALSE;
+
+  left = right = top = bottom = 0;
+
+  if (!_wnck_get_frame_extents (window->priv->xwindow,
+                                &left, &right, &top, &bottom))
+    return;
+
+  if (left   != window->priv->left_frame ||
+      right  != window->priv->right_frame ||
+      top    != window->priv->top_frame ||
+      bottom != window->priv->bottom_frame)
+    {
+      window->priv->left_frame   = left;
+      window->priv->right_frame  = right;
+      window->priv->top_frame    = top;
+      window->priv->bottom_frame = bottom;
+
+      emit_geometry_changed (window);
+    }
+}
+
+static void
+force_update_now (WnckWindow *window)
+{
+  WnckWindowState old_state;
+  WnckWindowState new_state;
+  WnckWindowActions old_actions;
+  
+  unqueue_update (window);
+
+  /* Name must be done before all other stuff,
+   * because we have iconsistent state across the
+   * update_name/update_icon_name functions (no window name),
+   * and we have to fix that before we emit any other signals
+   */
+
+  update_name (window);
+  update_icon_name (window);
+
+  if (window->priv->need_emit_name_changed)
+    emit_name_changed (window);
+
+  old_state = COMPRESS_STATE (window);
+  old_actions = window->priv->actions;
+
+  update_startup_id (window);    /* no side effects */
+  update_wmclass (window);
+  update_wmhints (window);
+  update_transient_for (window); /* wintype needs this to be first */
+  update_wintype (window);
+  update_wm_state (window);
+  update_state (window);     /* must come after the above, since they affect
+                              * our calculated state
+                              */
+  update_workspace (window); /* emits signals */
+  update_actions (window);
+  update_frame_extents (window); /* emits signals */
+
+  get_icons (window);
+  
+  new_state = COMPRESS_STATE (window);
+
+  if (old_state != new_state)
+    emit_state_changed (window, old_state ^ new_state, new_state);
+
+  if (old_actions != window->priv->actions)
+    emit_actions_changed (window, old_actions ^ window->priv->actions,
+                          window->priv->actions);
+  
+  if (window->priv->need_emit_icon_changed)
+    emit_icon_changed (window);
+}
+
+
+static gboolean
+update_idle (gpointer data)
+{
+  WnckWindow *window = WNCK_WINDOW (data);
+
+  window->priv->update_handler = 0;
+  force_update_now (window);
+  return FALSE;
+}
+
+static void
+queue_update (WnckWindow *window)
+{
+  if (window->priv->update_handler != 0)
+    return;
+
+  window->priv->update_handler = g_idle_add (update_idle, window);
+}
+
+static void
+unqueue_update (WnckWindow *window)
+{
+  if (window->priv->update_handler != 0)
+    {
+      g_source_remove (window->priv->update_handler);
+      window->priv->update_handler = 0;
+    }
+}
+
+static void
+emit_name_changed (WnckWindow *window)
+{
+  window->priv->need_emit_name_changed = FALSE;
+  g_signal_emit (G_OBJECT (window),
+                 signals[NAME_CHANGED],
+                 0);
+}
+
+static void
+emit_state_changed (WnckWindow     *window,
+                    WnckWindowState changed_mask,
+                    WnckWindowState new_state)
+{
+  g_signal_emit (G_OBJECT (window),
+                 signals[STATE_CHANGED],
+                 0, changed_mask, new_state);
+}
+
+static void
+emit_workspace_changed (WnckWindow *window)
+{
+  g_signal_emit (G_OBJECT (window),
+                 signals[WORKSPACE_CHANGED],
+                 0);
+}
+
+static void
+emit_icon_changed (WnckWindow *window)
+{
+  window->priv->need_emit_icon_changed = FALSE;
+  g_signal_emit (G_OBJECT (window),
+                 signals[ICON_CHANGED],
+                 0);
+}
+
+static void
+emit_actions_changed   (WnckWindow       *window,
+                        WnckWindowActions changed_mask,
+                        WnckWindowActions new_actions)
+{
+  g_signal_emit (G_OBJECT (window),
+                 signals[ACTIONS_CHANGED],
+                 0, changed_mask, new_actions);
+}
+
+static void
+emit_geometry_changed (WnckWindow *window)
+{
+  g_signal_emit (G_OBJECT (window),
+                 signals[GEOMETRY_CHANGED],
+                 0);
+}
diff -urN libwnck.orig/libwnck/window.h libwnck.new/libwnck/window.h
--- libwnck.orig/libwnck/window.h	2008-08-06 23:43:13.423557000 +0100
+++ libwnck.new/libwnck/window.h	2008-08-06 23:43:40.134710000 +0100
@@ -31,6 +31,7 @@
 #include <glib-object.h>
 #include <libwnck/screen.h>
 #include <gdk-pixbuf/gdk-pixbuf.h>
+#include <gdk/gdkcolor.h>
 
 G_BEGIN_DECLS
 
@@ -289,6 +290,14 @@
 const char* wnck_window_get_name      (WnckWindow *window);
 gboolean    wnck_window_has_icon_name (WnckWindow *window);
 const char* wnck_window_get_icon_name (WnckWindow *window);
+#ifdef HAVE_XTSOL
+const char* wnck_window_get_label	   (WnckWindow *window);
+char* wnck_window_get_label_human_readable (WnckWindow *window);
+GdkColor* wnck_window_get_label_color	   (WnckWindow *window);
+const char* wnck_window_get_label_color_str	   (WnckWindow *window);
+void wnck_window_update_label	       (WnckWindow *window);
+const char* wnck_window_get_role       (WnckWindow *window);
+#endif
 
 WnckApplication* wnck_window_get_application  (WnckWindow *window);
 WnckWindow*      wnck_window_get_transient    (WnckWindow *window);
@@ -321,6 +330,9 @@
 gboolean wnck_window_is_sticky                 (WnckWindow *window);
 gboolean wnck_window_needs_attention           (WnckWindow *window);
 gboolean wnck_window_or_transient_needs_attention (WnckWindow *window);
+#ifdef HAVE_XTSOL
+gboolean wnck_window_is_trusted                (WnckWindow *window);
+#endif
 
 void wnck_window_set_skip_pager    (WnckWindow *window,
                                     gboolean skip);
diff -urN libwnck.orig/libwnck/wnck-tsol.c libwnck.new/libwnck/wnck-tsol.c
--- libwnck.orig/libwnck/wnck-tsol.c	1970-01-01 01:00:00.000000000 +0100
+++ libwnck.new/libwnck/wnck-tsol.c	2008-08-06 23:43:40.140377000 +0100
@@ -0,0 +1,289 @@
+#include  <config.h>
+#ifdef HAVE_XTSOL
+
+#include <stdlib.h>
+#include <strings.h>
+#include <dlfcn.h>
+#include <link.h>
+#include <glib.h>
+#include "wnck-tsol.h"
+#include "tsol-pics.h"
+
+static
+void * dlopen_bsm (void)
+{
+	return dlopen ("/usr/lib/libbsm.so", RTLD_LAZY);
+}
+
+static
+void * dlopen_tsol (void)
+{
+   void  *handle = NULL;
+
+   /*
+    * No 64-bit version of libwnck so we can get away with hardcoding
+    * to a single path on this occasion
+    */
+   if ((handle = dlopen ("/usr/lib/libtsol.so.2", RTLD_LAZY)) != NULL)
+       return handle;
+   
+   return handle;
+}
+
+static
+void * dlopen_gnometsol (void)
+{
+   void  *handle = NULL;
+
+   if ((handle = dlopen ("/usr/lib/libgnometsol.so", RTLD_LAZY)) != NULL)
+       return handle;
+   
+   return handle;
+}
+
+static
+void * dlopen_xtsol (void)
+{
+   void  *handle = NULL;
+
+   if ((handle = dlopen ("/usr/lib/libXtsol.so.1", RTLD_LAZY)) != NULL)
+       return handle;
+   if ((handle = dlopen ("/usr/openwin/lib/libXtsol.so.1", RTLD_LAZY)) != NULL)
+       return handle;
+
+   return handle;
+}
+
+gboolean
+_wnck_use_trusted_extensions (void)
+{
+
+  static int trusted = -1;
+
+  /*
+   * Sun Trusted Extensions (tm) for Solaris (tm) support. 
+   *
+   * It is necessary to use dlopen because the label aware extensions to libwnck work
+   * only on systems with the trusted extensions installed and with the SUN_TSOL
+   * xserver extension present
+   */
+
+    if (trusted < 0) {
+      static gpointer bsm_handle = NULL;
+      static gpointer tsol_handle = NULL;
+      static gpointer xtsol_handle = NULL;
+      static gpointer gnometsol_handle = NULL;
+
+      if (getenv ("TRUSTED_SESSION") == NULL) {
+        trusted = 0;
+        return 0;
+      }   	
+
+		bsm_handle = dlopen_bsm ();
+        tsol_handle = dlopen_tsol ();
+		xtsol_handle = dlopen_xtsol ();
+
+        if (bsm_handle && tsol_handle && xtsol_handle) {
+           /* libbsm function (only interested in the one) */
+           libbsm_getdevicerange = (bsm_getdevicerange) dlsym (bsm_handle, "getdevicerange");
+
+           /* libtsol functions */
+           libtsol_label_to_str = (tsol_label_to_str) dlsym (tsol_handle, "label_to_str");
+           libtsol_str_to_label = (tsol_str_to_label) dlsym (tsol_handle, "str_to_label");
+           libtsol_m_label_free = (tsol_m_label_free) dlsym (tsol_handle, "m_label_free");
+
+           /* Other misc. libtsol functions */
+           libtsol_blminimum = (tsol_blminimum) dlsym (tsol_handle, "blminimum");
+           libtsol_blmaximum = (tsol_blmaximum) dlsym (tsol_handle, "blmaximum");
+           libtsol_blinrange = (tsol_blinrange) dlsym (tsol_handle, "blinrange");
+           libtsol_getuserrange = (tsol_getuserrange) dlsym (tsol_handle, "getuserrange");
+           libtsol_blabel_alloc = (tsol_blabel_alloc) dlsym (tsol_handle, "blabel_alloc");
+           libtsol_blabel_free  = (tsol_blabel_free)  dlsym (tsol_handle, "blabel_free");
+           libtsol_bsllow  = (tsol_bsllow)  dlsym (tsol_handle, "bsllow");
+           libtsol_bslhigh = (tsol_bslhigh) dlsym (tsol_handle, "bslhigh");
+
+
+
+           /* libXtsol functions */
+           libxtsol_XTSOLgetResLabel = (xtsol_XTSOLgetResLabel) dlsym (xtsol_handle,
+                                     "XTSOLgetResLabel");
+           libxtsol_XTSOLgetResUID = (xtsol_XTSOLgetResUID) dlsym (xtsol_handle,
+                                     "XTSOLgetResUID");
+           libxtsol_XTSOLgetWorkstationOwner = (xtsol_XTSOLgetWorkstationOwner) dlsym (xtsol_handle,
+                                     "XTSOLgetWorkstationOwner");
+           libxtsol_XTSOLIsWindowTrusted = (xtsol_XTSOLIsWindowTrusted) dlsym (xtsol_handle,
+                                     "XTSOLIsWindowTrusted");
+
+           if (libbsm_getdevicerange == NULL ||
+               libtsol_label_to_str == NULL ||
+               libtsol_str_to_label == NULL ||
+               libtsol_m_label_free == NULL ||
+               libtsol_blminimum == NULL ||
+               libtsol_blmaximum == NULL ||
+               libtsol_blinrange == NULL ||
+               libtsol_getuserrange == NULL ||
+               libtsol_blabel_alloc == NULL ||
+               libtsol_blabel_free  == NULL ||
+               libtsol_bsllow  == NULL ||
+               libtsol_bslhigh == NULL ||
+               libxtsol_XTSOLgetResLabel == NULL ||
+               libxtsol_XTSOLgetResUID == NULL ||
+               libxtsol_XTSOLgetWorkstationOwner == NULL ||
+               libxtsol_XTSOLIsWindowTrusted == NULL) {
+               dlclose (bsm_handle);
+               dlclose (tsol_handle);
+               dlclose (xtsol_handle);
+               bsm_handle = NULL;
+               tsol_handle = NULL;
+               xtsol_handle = NULL;
+            }
+        }
+	gnometsol_handle = dlopen_gnometsol ();
+	if (gnometsol_handle != NULL)
+	  {
+	    libgnome_tsol_constraint_image_render = (gnome_tsol_constraint_image_render) dlsym (gnometsol_handle, "gnome_tsol_constraint_image_render");
+	    libgnome_tsol_constraint_image_set_border = (gnome_tsol_constraint_image_set_border) dlsym (gnometsol_handle, "gnome_tsol_constraint_image_set_border");
+	    libgnome_tsol_constraint_image_set_stretch = (gnome_tsol_constraint_image_set_stretch) dlsym (gnometsol_handle, "gnome_tsol_constraint_image_set_stretch");
+	    libgnome_tsol_constraint_image_colorize = (gnome_tsol_constraint_image_colorize) dlsym (gnometsol_handle, "gnome_tsol_constraint_image_colorize");
+
+	    if (libgnome_tsol_constraint_image_render == NULL ||
+		libgnome_tsol_constraint_image_set_border == NULL ||
+		libgnome_tsol_constraint_image_set_stretch == NULL ||
+		libgnome_tsol_constraint_image_colorize == NULL)
+		gnometsol_handle = NULL;
+
+	  }
+	trusted = ((bsm_handle != NULL) && (tsol_handle != NULL) && (xtsol_handle != NULL) && (gnometsol_handle != NULL)) ? 1 : 0;
+    }
+    return trusted ? TRUE : FALSE;
+}
+
+const char *
+_wnck_get_min_label ()
+{
+    static char *min_label = NULL;
+
+    if (!min_label) {
+        min_label = (char *) getenv ("USER_MIN_SL");
+    }
+    return min_label;
+}
+
+const char*
+_wnck_get_max_label()
+{
+    static char *max_label = NULL;
+
+    if (!max_label) {
+        max_label = (char *) getenv ("USER_MAX_SL");
+    }
+    return max_label;
+}
+
+
+/* GFX part */
+
+
+typedef struct _HighlightStripe HighlightStripe;
+
+struct _HighlightStripe
+{
+  ConstraintImage *image;
+  char		  *name;
+};
+
+static gint
+label_string_compare (HighlightStripe *tmp, char *searched_label)
+{
+  return strcmp (searched_label, tmp->name);  
+}
+
+ConstraintImage * 
+get_highlight_stripe (char     *name,
+		      GdkColor *label_color)
+{
+  static GSList *hl_stripe_list = NULL;
+  GSList *stored_hl_stripe = NULL;
+  HighlightStripe *hl_stripe;
+
+  if ((name == NULL) || (label_color == NULL))
+    return NULL;
+    
+
+  stored_hl_stripe = g_slist_find_custom (hl_stripe_list, 
+					  name, 
+					  (GCompareFunc)label_string_compare);
+  if (stored_hl_stripe)
+    return ((HighlightStripe* )stored_hl_stripe->data)->image;
+ 
+  hl_stripe = g_new0 (HighlightStripe, 1);
+
+  hl_stripe->name = g_strdup (name);
+
+  hl_stripe->image = g_new0 (ConstraintImage, 1);
+
+  hl_stripe->image->pixbuf = gdk_pixbuf_new_from_inline (-1, 
+							  highlight_stripe_pb, 
+							  TRUE, NULL);
+  
+  libgnome_tsol_constraint_image_set_border (hl_stripe->image, 3, 0, 1, 1);
+  libgnome_tsol_constraint_image_set_stretch (hl_stripe->image, TRUE);
+  libgnome_tsol_constraint_image_colorize (hl_stripe->image, label_color, 255, TRUE);
+  
+  hl_stripe_list = g_slist_append (hl_stripe_list, hl_stripe);
+  return hl_stripe->image; 
+}
+
+static gboolean label_expose_event (GtkWidget        *widget,
+				    GdkEventExpose   *event,
+				    gpointer          data)
+{
+  WnckWindow *window = (WnckWindow *) data;
+
+  GdkGC *tmp_gc = gdk_gc_new (widget->window);
+  gdk_gc_set_rgb_fg_color (tmp_gc, wnck_window_get_label_color (window));
+
+  gdk_draw_rectangle (widget->window, 
+		      widget->style->black_gc,
+		      FALSE,
+		      event->area.x, event->area.y,
+		      event->area.width - 1, event->area.height - 1);
+  
+  gdk_draw_rectangle (widget->window, 
+		      tmp_gc,
+		      TRUE,
+		      event->area.x + 1, event->area.y + 1,
+		      event->area.width - 2, event->area.height - 2);
+
+  g_object_unref (tmp_gc);
+
+  return FALSE;
+}
+
+GtkWidget *
+window_menu_create_label_indicator (WnckWindow *window, 
+				    GtkWidget  *image)
+{
+  GtkWidget *da, *hbox;
+  da = gtk_drawing_area_new ();
+  
+  g_signal_connect (G_OBJECT (da), "expose_event",  
+		    G_CALLBACK (label_expose_event), 
+		    window);
+  
+  gtk_widget_set_size_request (da, 5, -1);
+  
+  hbox = gtk_hbox_new (FALSE, 4);
+  
+  gtk_container_add (GTK_CONTAINER (hbox), da);
+  gtk_container_add (GTK_CONTAINER (hbox), image);
+  
+  gtk_widget_show (da);
+  gtk_widget_show (hbox);
+  gtk_widget_show (image);
+
+  return hbox;
+}
+
+
+#endif /* HAVE_XTSOL */
diff -urN libwnck.orig/libwnck/wnck-tsol.h libwnck.new/libwnck/wnck-tsol.h
--- libwnck.orig/libwnck/wnck-tsol.h	1970-01-01 01:00:00.000000000 +0100
+++ libwnck.new/libwnck/wnck-tsol.h	2008-08-06 23:43:40.142752000 +0100
@@ -0,0 +1,133 @@
+#ifndef __WNCK_TSOL_H__
+#define __WNCK_TSOL_H__
+
+#include <config.h>
+
+#ifdef HAVE_XTSOL
+#include <pwd.h>
+#include <glib-2.0/glib.h>
+#include <tsol/label.h>
+#include <sys/tsol/label_macro.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/Xtsol.h>
+#include <gtk/gtk.h>
+#include "libwnck.h"
+
+typedef struct _ConstraintImage ConstraintImage;
+struct _ConstraintImage
+{
+  gchar     *filename;
+  GdkPixbuf *pixbuf;
+  GdkPixbuf *scaled;
+  gboolean   stretch;
+  gint       border_left;
+  gint       border_right;
+  gint       border_bottom;
+  gint       border_top;
+  guint      hints[3][3];
+  gboolean   recolorable;
+  GdkColor   colorize_color;
+  gboolean   use_as_bkg_mask;
+};
+
+/* libbsm provides getdevicerange(3TSOL) - don't believe the man page */
+typedef blrange_t*	(*bsm_getdevicerange) (const char *device);
+
+/* Libtsol functions */
+typedef int     (*tsol_label_to_str) (const m_label_t *label, char **string,
+				      const m_label_str_t conversion_type, 
+				      uint_t flags);
+typedef int	(*tsol_str_to_label) (const char *string, m_label_t **label,
+				      const m_label_type_t label_type, 
+				      uint_t flags,
+				      int *error);
+
+typedef void	(*tsol_m_label_free) (m_label_t *label);
+
+/* Other misc. libtsol functions */
+typedef blrange_t*	(*tsol_getuserrange) (const char *username);
+typedef int		(*tsol_blinrange)    (const m_label_t *label,
+					      const blrange_t *range);
+typedef void		(*tsol_blminimum)    (m_label_t *minimum_label,
+					      const m_label_t *bounding_label);
+typedef void		(*tsol_blmaximum)    (m_label_t *maximum_label,
+					      const m_label_t *bounding_label);
+typedef m_label_t*	(*tsol_blabel_alloc) (void);
+typedef void		(*tsol_blabel_free)  (m_label_t *label_p);
+typedef void		(*tsol_bsllow)  (m_label_t *label);
+typedef void		(*tsol_bslhigh) (m_label_t *label);
+
+/* libXtsol functions */
+typedef Status	(*xtsol_XTSOLgetResLabel) (Display *dpy, XID xid,
+                 ResourceType resourceFlag, bslabel_t *sl);
+typedef Status	(*xtsol_XTSOLgetResUID) (Display *dpy, XID object,
+                 ResourceType resourceFlag,
+                 uid_t *uidp);
+typedef Status	(*xtsol_XTSOLgetWorkstationOwner) (Display *dpy, uid_t *uidp);
+typedef Bool    (*xtsol_XTSOLIsWindowTrusted) (Display *dpy, Window win); 
+
+/* libgnometsol functions */
+typedef void  (*gnome_tsol_constraint_image_render) (ConstraintImage *cimage,
+						     GdkWindow    *window,
+						     GdkBitmap    *mask,
+						     GdkRectangle *clip_rect,
+						     gboolean      center,		   
+						     gint          x,
+						     gint          y,
+						     gint          width,
+						     gint          height);
+
+typedef void (*gnome_tsol_constraint_image_set_border) (ConstraintImage *pb,
+							gint         left,
+							gint         right,
+							gint         top,
+							gint         bottom);
+
+typedef void (*gnome_tsol_constraint_image_set_stretch) (ConstraintImage *pb,
+							 gboolean     stretch);
+
+typedef void (*gnome_tsol_constraint_image_colorize) (ConstraintImage *image,
+						      GdkColor  *color,
+						      int	alpha,
+						      gboolean   use_alpha);
+
+/* libbsm functions */
+bsm_getdevicerange	libbsm_getdevicerange;
+/* libtsol functions*/
+tsol_label_to_str	libtsol_label_to_str;
+tsol_str_to_label	libtsol_str_to_label;
+tsol_m_label_free	libtsol_m_label_free;
+/* Other misc. libtsol functions */
+tsol_blminimum		libtsol_blminimum;
+tsol_blmaximum		libtsol_blmaximum;
+tsol_blinrange      libtsol_blinrange;
+tsol_getuserrange	libtsol_getuserrange;
+tsol_blabel_alloc	libtsol_blabel_alloc;
+tsol_blabel_free	libtsol_blabel_free;
+tsol_bsllow			libtsol_bsllow;
+tsol_bslhigh		libtsol_bslhigh;
+
+xtsol_XTSOLgetResLabel	libxtsol_XTSOLgetResLabel;
+xtsol_XTSOLgetResUID	libxtsol_XTSOLgetResUID;
+xtsol_XTSOLgetWorkstationOwner	libxtsol_XTSOLgetWorkstationOwner;
+xtsol_XTSOLIsWindowTrusted	libxtsol_XTSOLIsWindowTrusted;
+
+gnome_tsol_constraint_image_render libgnome_tsol_constraint_image_render;
+gnome_tsol_constraint_image_set_border libgnome_tsol_constraint_image_set_border;
+gnome_tsol_constraint_image_set_stretch libgnome_tsol_constraint_image_set_stretch;
+gnome_tsol_constraint_image_colorize libgnome_tsol_constraint_image_colorize;
+
+const char* _wnck_get_min_label ();
+const char* _wnck_get_max_label ();
+
+
+/* GFX part */
+
+ConstraintImage* get_highlight_stripe (char*	  name,
+				       GdkColor*  label_color);
+
+GtkWidget*	 window_menu_create_label_indicator (WnckWindow *window, 
+						     GtkWidget  *image);
+
+#endif /* HAVE_XTSOL */
+#endif
diff -urN libwnck.orig/libwnck/workspace.c libwnck.new/libwnck/workspace.c
--- libwnck.orig/libwnck/workspace.c	2008-08-06 23:43:13.502854000 +0100
+++ libwnck.new/libwnck/workspace.c	2008-08-06 23:51:01.138260000 +0100
@@ -26,6 +26,16 @@
 #include <config.h>
 
 #include <glib/gi18n-lib.h>
+#ifdef HAVE_XTSOL
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <user_attr.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/Xtsol.h>
+#include <libgnometsol/userattr.h>
+#include <wnck-tsol.h>
+#endif
 #include "workspace.h"
 #include "xutils.h"
 #include "private.h"
@@ -69,6 +79,13 @@
   WnckScreen *screen;
   int number;
   char *name;
+#ifdef HAVE_XTSOL  /* TSOL */
+  char *label; /* Workspace sensitivity label */
+  char *role;  /* Workspace role : login name. Set only once */
+  /* The workspace range can differ for Workstation Owner and role workspaces */
+  const blrange_t *ws_range;
+#endif
+
   int width, height;            /* Workspace size */
   int viewport_x, viewport_y;   /* Viewport origin */
   gboolean is_virtual;
@@ -79,6 +96,10 @@
 
 enum {
   NAME_CHANGED,
+#ifdef HAVE_XTSOL
+  LABEL_CHANGED,
+  ROLE_CHANGED,
+#endif
   LAST_SIGNAL
 };
 
@@ -91,6 +112,12 @@
 
 static guint signals[LAST_SIGNAL] = { 0 };
 
+#ifdef HAVE_XTSOL
+static void emit_label_changed (WnckWorkspace *space);
+static void emit_role_changed (WnckWorkspace *space);
+static blrange_t * get_display_range (void);
+#endif
+
 static void
 wnck_workspace_init (WnckWorkspace *workspace)
 {
@@ -104,6 +131,9 @@
   workspace->priv->viewport_x = 0;
   workspace->priv->viewport_y = 0;
   workspace->priv->is_virtual = FALSE;
+#ifdef HAVE_XTSOL
+  workspace->priv->ws_range = NULL;
+#endif
 }
 
 static void
@@ -129,6 +159,24 @@
                   NULL, NULL,
                   g_cclosure_marshal_VOID__VOID,
                   G_TYPE_NONE, 0);
+#ifdef HAVE_XTSOL
+  signals[LABEL_CHANGED] =
+    g_signal_new ("label_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWorkspaceClass, label_changed),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+  signals[ROLE_CHANGED] =
+    g_signal_new ("role_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWorkspaceClass, role_changed),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+#endif
 }
 
 static void
@@ -140,6 +188,11 @@
 
   g_free (workspace->priv->name);
   workspace->priv->name = NULL;
+
+#ifdef HAVE_XTSOL
+  g_free (workspace->priv->role);
+  g_free (workspace->priv->label);
+#endif
   
   G_OBJECT_CLASS (wnck_workspace_parent_class)->finalize (object);
 }
@@ -179,6 +232,134 @@
   return space->priv->name;
 }
 
+#ifdef HAVE_XTSOL
+/**
+ * wnck_workspace_get_label_range:
+ * @space: a #WnckWorkspace
+ * @min_label: a string pointer to pointer to the minimum valid label value for @space
+ * @max_label: a string pointer to pointer to the maximum valid label value for @space
+ *
+ * Gets the sensitivity label range for the specified workspace when
+ * running in a label aware desktop session. @min_label represents the minimum
+ * sensitivity label that the #WnckWorkspace, @space, may be assigned.
+ * @max_label represents the maximum sensitivity label thatthe #WnckWorkspace,
+ * @space may be assigned. Both min_label and max_label are allocated memory
+ * on behalf of the caller. It is the caller's responsibility to free the memory
+ * pointed to by @min_label and @max_label.
+ *
+ * Return value: 0 on success, non zero on failure.
+ **/
+int
+wnck_workspace_get_label_range (WnckWorkspace *space, char **min_label, char **max_label)
+{
+  int error = 0;
+  blrange_t *brange;
+  g_return_val_if_fail (WNCK_IS_WORKSPACE (space), -1);
+
+  if (! _wnck_check_xtsol_extension ())
+      return -1;
+
+  if (!_wnck_use_trusted_extensions())
+      return -1;
+
+  brange = _wnck_workspace_get_range (space);
+  if (!brange)
+      return -1;
+
+  if (libtsol_label_to_str (brange->lower_bound, min_label, M_INTERNAL,
+                        LONG_NAMES) != 0) {
+      g_warning ("wnck_workspace_get_label_range: Workspace has an invalid minimum label bound");
+      return -1;
+  }
+
+  if (libtsol_label_to_str (brange->upper_bound, max_label, M_INTERNAL,
+                        LONG_NAMES) != 0) {
+      g_warning ("wnck_workspace_get_label_range: Workspace has an invalid maximum label bound");
+      return -1;
+  }
+  return 0;
+}
+
+/**
+ * wnck_workspace_get_label:
+ * @space: a #WnckWorkspace
+ *
+ * Gets the sensitivity label as an hex number for the specified 
+ * workspace when running in a label aware desktop session.
+ *
+ * Return value: workspace sensitivity label, %NULL on failure.
+ **/
+const char*
+wnck_workspace_get_label (WnckWorkspace *space)
+{
+  g_return_val_if_fail (WNCK_IS_WORKSPACE (space), NULL);
+  /* A bit anal perhaps but I'd rather make sure nothing useful is returned */
+  if (! (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions()) )
+    return NULL;
+  return space->priv->label;
+}
+
+/**
+ * wnck_workspace_get_human_readable_label:
+ * @space: a #WnckWorkspace
+ *
+ * Gets the sensitivity label as a string for the specified workspace when
+ * running in a label aware desktop session.
+ * 
+ *
+ * Return value: workspace sensitivity label, %NULL on failure.
+ **/
+char*
+wnck_workspace_get_human_readable_label (WnckWorkspace *space)
+{
+  const char *hex_label;
+  char *human_readable_label;
+  int error;
+  m_label_t *mlabel = NULL;
+  
+  g_return_val_if_fail (WNCK_IS_WORKSPACE (space), NULL);
+  if (! (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions()) )
+    return NULL;
+
+  hex_label = space->priv->label;
+
+  if (hex_label && (error = libtsol_str_to_label (hex_label, &mlabel, MAC_LABEL, 
+			    L_NO_CORRECTION, &error) == 0))
+    {
+      error = libtsol_label_to_str (mlabel, 
+			    &human_readable_label, 
+			    M_LABEL, DEF_NAMES);
+      if (strcmp (human_readable_label, "ADMIN_HIGH") == 0 ||
+	  strcmp (human_readable_label, "ADMIN_LOW") == 0)
+	/* SUN_BRANDING TJDS */
+	return g_strdup (_("Trusted Path"));
+      return human_readable_label;
+    }
+  return NULL;
+}
+
+
+/**
+ * wnck_workspace_get_role:
+ * @space: a #WnckWorkspace
+ *
+ * Gets the role (login name) for the specified workspace when
+ * running in a trusted desktop session.
+ *
+ * Return value: workspace user role, %NULL on failure.
+ **/
+const char*
+wnck_workspace_get_role (WnckWorkspace *space)
+{
+  g_return_val_if_fail (WNCK_IS_WORKSPACE (space), NULL);
+  /* Make sure to return NULL for non-tsol */
+  if (! (_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions()) )
+    return NULL;
+  return space->priv->role;
+}
+#endif /* HAVE_XTSOL */
+
+
 /**
  * wnck_workspace_change_name:
  * @space: a #WnckWorkspace.
@@ -217,6 +398,29 @@
   return space->priv->screen;
 }
 
+#ifdef HAVE_XTSOL
+/**
+ * wnck_workspace_change_label:
+ * @space: a #WnckWorkspace
+ * @label: new workspace sensitivity label
+ *
+ * Try changing the sensitivity label of the workspace.
+ *
+ **/
+
+void
+wnck_workspace_change_label (WnckWorkspace *space,
+                             const char    *label)
+{
+  g_return_if_fail (WNCK_IS_WORKSPACE (space));
+  g_return_if_fail (label != NULL);
+
+  _wnck_screen_change_workspace_label (space->priv->screen,
+                                       space->priv->number,
+                                       label);
+}
+#endif
+
 /**
  * wnck_workspace_activate:
  * @space: a #WnckWorkspace.
@@ -254,6 +458,7 @@
   space->priv->screen = screen;
 
   _wnck_workspace_update_name (space, NULL);
+/* FIXME - do label and role need to be updated here? */  
   
   /* Just set reasonable defaults */
   space->priv->width = wnck_screen_get_width (screen);
@@ -289,6 +494,251 @@
   g_free (old);
 }
 
+#ifdef HAVE_XTSOL
+
+static char*
+get_workstationowner (void)
+{
+  static char *workstationowner = NULL;
+  uid_t wsuid;
+  struct passwd *pwd;
+
+  if (workstationowner == NULL) {
+    if ((libxtsol_XTSOLgetWorkstationOwner (gdk_x11_get_default_xdisplay (),
+					    &wsuid)) < 0) {
+      g_warning ("XTSOLgetWorkstationOwner() failed. Using getuid() instead");
+      pwd = getpwuid (getuid ());
+    } else {
+      pwd = getpwuid (wsuid);
+    }
+    
+    workstationowner = g_strdup (pwd->pw_name);
+  }
+ 
+  return workstationowner;
+}
+
+void
+_wnck_workspace_update_label (WnckWorkspace *space,
+                              const char    *label)
+{
+  char *old;
+
+  g_return_if_fail (WNCK_IS_WORKSPACE (space));
+  /* Don't do anything unless this is a trusted system */
+  if (!(_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions()))
+      return;
+
+  /* Should a warning be called here? */
+  if (label == NULL)
+	g_warning("Workspace %d label is null\n",
+                   wnck_workspace_get_number (space));
+
+  old = space->priv->label;
+  space->priv->label = g_strdup (label);
+
+  /*
+   *Initialise the label range for this workspace
+   */
+
+  if (!space->priv->ws_range) {
+      if ((!space->priv->role) || (strlen (space->priv->role) == 0) ||
+	   (strcmp (space->priv->role, get_workstationowner ()) == 0)) {
+          blrange_t		*range;
+          int error;
+          char *min_label = NULL;
+          char *max_label = NULL;
+          range = g_malloc (sizeof (blrange_t));
+          range->lower_bound = range->upper_bound = NULL;
+     
+          min_label = g_strdup (_wnck_get_min_label ());
+          max_label = g_strdup (_wnck_get_max_label ());
+
+          if (libtsol_str_to_label (min_label, &(range->lower_bound),
+                                    MAC_LABEL, L_NO_CORRECTION, &error) < 0) {
+              g_warning ("Couldn't determine minimum workspace label");
+              g_free (min_label);
+              g_free (max_label);
+              return;
+          }
+          if (libtsol_str_to_label (max_label, &(range->upper_bound),
+                                    USER_CLEAR, L_NO_CORRECTION, &error) < 0) {
+              g_warning ("Couldn't determine workspace clearance");
+              g_free (min_label);
+              g_free (max_label);
+              return;
+          }
+          space->priv->ws_range = range;
+          g_free (min_label);
+          g_free (max_label);
+
+      } else {
+          int           error;
+          blrange_t     *role_range;
+          blrange_t		*disp_range;
+          userattr_t	*u_ent; 
+          /* 
+           * This is a role workspace so we need to construct the correct label range
+           * instead of relying on USER_MIN_SL and USER_MAX_SL
+           */
+          if ((role_range = libtsol_getuserrange (space->priv->role)) == NULL) {
+              g_warning ("Couldn't get label range for %s\n", space->priv->role);
+              return;
+          }
+
+    	  /* Get display device's range */
+    	  if ((disp_range = get_display_range ()) == NULL) {
+    		  g_warning ("Couldn't get the display's device range");
+    		  return;
+    	  }
+
+          /*
+           * Determine the low & high bound of the label range
+           * where the role user can operate. This is the
+           * intersection of display label range & role label
+           * range.
+           */
+          libtsol_blmaximum (role_range->lower_bound, disp_range->lower_bound);
+          libtsol_blminimum (role_range->upper_bound, disp_range->upper_bound);
+          space->priv->ws_range = role_range;
+          libtsol_blabel_free (disp_range->lower_bound);
+          libtsol_blabel_free (disp_range->upper_bound);
+          free (disp_range);
+      }
+  }
+  /* Should we put a g_warning here? */
+  /* if (space->priv->label == NULL) */
+
+  if ((!old && label) ||
+      (old && label && strcmp (old, label) != 0))
+    emit_label_changed (space);
+
+  g_free (old);
+}
+
+void
+_wnck_workspace_update_role (WnckWorkspace *space,
+                             const char    *role)
+{
+	char *workstationowner = NULL;
+	char *old;
+
+	g_return_if_fail (WNCK_IS_WORKSPACE (space));
+	/* Check for a multi label trusted environment first */
+	if (!(_wnck_check_xtsol_extension() && _wnck_use_trusted_extensions()))
+		return;
+	workstationowner = get_workstationowner ();
+
+	if (role == NULL)
+		return;
+	old = space->priv->role;
+
+	/* Check the the workspace role really is changing */
+	if ((!old && role) ||
+		(old && role && strcmp (old, role) != 0)) {
+		g_free (space->priv->role);
+		if (strlen (role) ==0)
+			{ space->priv->role = g_strdup (workstationowner); return;}
+		else
+			space->priv->role = g_strdup (role);
+
+		/*
+		 * A role change requires that the label range of the 
+		 * workspace be reset. The label also needs to be 
+		 * silently set to the lowest in the range.
+		 */
+
+		if (space->priv->ws_range) {
+			libtsol_blabel_free (space->priv->ws_range->lower_bound);
+			libtsol_blabel_free (space->priv->ws_range->upper_bound);
+			/* FIXME - man pages tell me to use free but generates a compiler warning */
+			free ((void *)space->priv->ws_range);
+		}
+
+		if (strcmp (space->priv->role, workstationowner) == 0) {
+			/* Workstation owner, so it's not a real role */
+			blrange_t		*range;
+			int error;
+			char *min_label = NULL;
+			char *max_label = NULL;
+			range = g_malloc (sizeof (blrange_t));
+			range->lower_bound = range->upper_bound = NULL;
+ 
+			min_label = g_strdup (_wnck_get_min_label ());
+			max_label = g_strdup (_wnck_get_max_label ());
+
+			/* Workspace label must be reset by default to the min_label value */
+			if (space->priv->label)
+				g_free (space->priv->label);
+				space->priv->label = g_strdup (min_label);  
+
+			if (libtsol_str_to_label (min_label, &(range->lower_bound),
+					MAC_LABEL, L_NO_CORRECTION, &error) < 0) {
+				g_warning ("Couldn't determine minimum workspace label");
+				g_free (min_label);
+				g_free (max_label);
+				return;
+			}
+
+			if (libtsol_str_to_label (max_label, &(range->upper_bound),
+				USER_CLEAR, L_NO_CORRECTION, &error) < 0) {
+				g_warning ("Couldn't determine workspace clearance");
+				g_free (min_label);
+				g_free (max_label);
+				return;
+    	  	}
+
+			space->priv->ws_range = range;
+			g_free (min_label);
+			g_free (max_label);
+
+		} else {
+			int           error;
+			blrange_t     *role_range;
+			blrange_t		*disp_range;
+			userattr_t	*u_ent;
+
+			/* 
+			 * This is a role workspace so we need to construct the correct label range
+			 * instead of relying on USER_MIN_SL and USER_MAX_SL
+			 */
+			if ((role_range = libtsol_getuserrange (space->priv->role)) == NULL) {
+				g_warning ("Couldn't get label range for %s\n", space->priv->role);
+				return;
+			}
+
+			/* Get display device's range */
+			if ((disp_range = get_display_range ()) == NULL) {
+				g_warning ("Couldn't get the display's device range");
+				return;
+			}
+
+			/*
+			 * Determine the low & high bound of the label range
+			 * where the role user can operate. This is the
+			 * intersection of display label range & role label
+			 * range.
+			 */
+			libtsol_blmaximum (role_range->lower_bound, disp_range->lower_bound);
+			libtsol_blminimum (role_range->upper_bound, disp_range->upper_bound);
+			space->priv->ws_range = role_range;
+
+			/* Workspace label must be reset by default to the lower_bound value */
+			if (libtsol_label_to_str (role_range->lower_bound, &space->priv->label, M_INTERNAL,
+					LONG_NAMES) != 0) {
+				/* Weird - default to admin_low */
+        		space->priv->label = g_strup ("ADMIN_LOW");
+			}
+
+			libtsol_blabel_free (disp_range->lower_bound);
+			libtsol_blabel_free (disp_range->upper_bound);
+			free (disp_range);
+		}
+    	emit_role_changed (space);
+	}
+}
+#endif /* HAVE_XTSOL */
+
 static void
 emit_name_changed (WnckWorkspace *space)
 {
@@ -297,6 +747,24 @@
                  0);
 }
 
+#ifdef HAVE_XTSOL
+static void
+emit_label_changed (WnckWorkspace *space)
+{
+  g_signal_emit (G_OBJECT (space),
+                 signals[LABEL_CHANGED],
+                 0);
+}
+
+static void
+emit_role_changed (WnckWorkspace *space)
+{
+  g_signal_emit (G_OBJECT (space),
+                 signals[ROLE_CHANGED],
+                 0);
+}
+#endif /* HAVE_XTSOL */
+
 gboolean
 _wnck_workspace_set_geometry (WnckWorkspace *space,
                               int            w,
@@ -612,3 +1080,33 @@
 
   return wnck_screen_get_workspace (space->priv->screen, index);
 }
+
+#ifdef HAVE_XTSOL
+/*
+ * These private (hint hint) functions assume that they have been called
+ * from within a trusted desktop session. The caller must ensure that
+ * this is the case otherwise it will trigger a load of the potentially
+ * non existant tsol and xtsol libs. That would be bad!
+ */
+static blrange_t *
+get_display_range (void)
+{
+  blrange_t       *range = NULL;
+
+  range = libbsm_getdevicerange ("framebuffer");
+  if (range == NULL) {
+    range = g_malloc (sizeof (blrange_t));
+    range->lower_bound = libtsol_blabel_alloc ();
+    range->upper_bound = libtsol_blabel_alloc ();
+    libtsol_bsllow  (range->lower_bound);
+    libtsol_bslhigh (range->upper_bound);
+  }
+  return (range);
+}
+
+blrange_t *
+_wnck_workspace_get_range (WnckWorkspace *space)
+{
+  return space->priv->ws_range;
+}
+#endif
diff -urN libwnck.orig/libwnck/workspace.h libwnck.new/libwnck/workspace.h
--- libwnck.orig/libwnck/workspace.h	2008-08-06 23:43:13.464638000 +0100
+++ libwnck.new/libwnck/workspace.h	2008-08-06 23:43:40.159050000 +0100
@@ -57,6 +57,11 @@
   GObjectClass parent_class;
 
   void (* name_changed) (WnckWorkspace *space);
+
+#ifdef HAVE_XTSOL
+  void (* label_changed) (WnckWorkspace *space);
+  void (* role_changed)  (WnckWorkspace *space);
+#endif
   
   /* Padding for future expansion */
   void (* pad1) (void);
@@ -69,9 +74,22 @@
 
 int         wnck_workspace_get_number     (WnckWorkspace *space);
 const char* wnck_workspace_get_name       (WnckWorkspace *space);
+#ifdef HAVE_XTSOL
+int        wnck_workspace_get_label_range(WnckWorkspace *space,
+                                          char **min_label,
+                                          char **max_label);
+const char*        wnck_workspace_get_label      (WnckWorkspace *space);
+char*      wnck_workspace_get_human_readable_label (WnckWorkspace *space);
+const char*        wnck_workspace_get_role       (WnckWorkspace *space);
+#endif
+
 void        wnck_workspace_change_name    (WnckWorkspace *space,
                                            const char    *name);
 WnckScreen* wnck_workspace_get_screen     (WnckWorkspace *space);
+#ifdef HAVE_XTSOL
+void        wnck_workspace_change_label   (WnckWorkspace *space,
+                                           const char    *label);
+#endif
 void        wnck_workspace_activate       (WnckWorkspace *space,
                                            guint32        timestamp);
 int         wnck_workspace_get_width      (WnckWorkspace *space);
diff -urN libwnck.orig/libwnck/xutils.c libwnck.new/libwnck/xutils.c
--- libwnck.orig/libwnck/xutils.c	2008-08-06 23:43:13.631420000 +0100
+++ libwnck.new/libwnck/xutils.c	2008-08-06 23:43:40.166864000 +0100
@@ -27,6 +27,7 @@
 #include <stdio.h>
 #include "screen.h"
 #include "window.h"
+#include "wnck-tsol.h"
 #include "private.h"
 #include "inlinepixbufs.h"
 
@@ -231,6 +232,21 @@
   return TRUE;
 }
 
+#ifdef HAVE_XTSOL
+gboolean
+_wnck_check_xtsol_extension ()
+{
+  static int foundxtsol = -1;
+  int major_code, first_event, first_error;
+
+  if (foundxtsol < 0) { 
+      foundxtsol = XQueryExtension (gdk_display, "SUN_TSOL", &major_code,
+                                    &first_event, &first_error);
+  }
+  return foundxtsol;
+}
+#endif
+
 static char*
 text_property_to_utf8 (const XTextProperty *prop)
 {
